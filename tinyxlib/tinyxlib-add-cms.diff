diff --git a/libtinyX11/AddDIC.c b/libtinyX11/AddDIC.c
new file mode 100644
index 0000000..ecc6650
--- /dev/null
+++ b/libtinyX11/AddDIC.c
@@ -0,0 +1,149 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsAddDIC.c
+ *
+ *	DESCRIPTION
+ *		Source for XcmsAddColorSpace
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+
+/*
+ *      DEFINES
+ */
+#define NextUnregDiCsID(lastid) \
+	    (XCMS_UNREG_ID(lastid) ? ++lastid : XCMS_FIRST_UNREG_DI_ID)
+#define MAX(x,y) ((x) < (y) ? (y) : (x))
+
+
+/*
+ *	NAME
+ *		XcmsAddColorSpace - Add a Device-Independent Color Space
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsAddColorSpace(XcmsColorSpace *pCS)
+/*
+ *	DESCRIPTION
+ *		DI Color Spaces are managed on a global basis.
+ *		This means that with exception of the provided DI color spaces:
+ *			CIEXYZ, CIExyY, CIELab, CIEuvY, CIELuv, and TekHVC
+ *		DI color spaces may have different XcmsColorFormat IDs between
+ *		clients.  So, you must be careful when using XcmsColor
+ *		structures between clients!  Use the routines XcmsFormatOfPrefix()
+ *		and XcmsPrefixOfFormat() appropriately.
+ *
+ *	RETURNS
+ *		XcmsSuccess if succeeded, otherwise XcmsFailure
+ */
+{
+    XcmsColorSpace **papColorSpaces;
+    XcmsColorSpace *ptmpCS;
+    XcmsColorFormat lastID = 0;
+
+    if ((pCS->id = _XcmsRegFormatOfPrefix(pCS->prefix)) != 0) {
+	if (XCMS_DD_ID(pCS->id)) {
+	    /* This is a Device-Dependent Color Space */
+	    return(XcmsFailure);
+	}
+	/*
+	 * REGISTERED DI Color Space
+	 *    then see if the color space has already been added to the
+	 *    system:
+	 *	    a. If the same ID/prefix and same XcmsColorSpec is found,
+	 *		then its a duplicate, so return success.
+	 *	    b. If same ID/prefix but different XcmsColorSpec is
+	 *		found, then add the color space to the front of the
+	 *		list using the same ID.  This allows one to override
+	 *		an existing DI Color Space.
+	 *	    c. Otherwise none found so just add the color space.
+	 */
+	if ((papColorSpaces = _XcmsDIColorSpaces) != NULL) {
+	    while ((ptmpCS = *papColorSpaces++) != NULL) {
+		if (pCS->id == ptmpCS->id) {
+		    if (pCS == ptmpCS) {
+			/* a. duplicate*/
+			return(XcmsSuccess);
+		    }
+		    /* b. same ID/prefix but different XcmsColorSpace */
+		    break;
+		}
+	    }
+	}
+	/* c. None found */
+    } else {
+	/*
+	 * UNREGISTERED DI Color Space
+	 *    then see if the color space has already been added to the
+	 *    system:
+	 *	    a. If same prefix and XcmsColorSpec, then
+	 *		its a duplicate ... return success.
+	 *	    b. If same prefix but different XcmsColorSpec, then
+	 *		add the color space to the front of the list using
+	 *		the same ID.  This allows one to override an existing
+	 *		DI Color Space.
+	 *	    c. Otherwise none found so, add the color space using the
+	 *		next unregistered ID for the connection.
+	 */
+	if ((papColorSpaces = _XcmsDIColorSpaces) != NULL) {
+	    while ((ptmpCS = *papColorSpaces++) != NULL) {
+		lastID = MAX(lastID, ptmpCS->id);
+		if (strcmp(pCS->prefix, ptmpCS->prefix) == 0) {
+		    if (pCS == ptmpCS) {
+			/* a. duplicate */
+			return(XcmsSuccess);
+		    }
+		    /* b. same prefix but different XcmsColorSpec */
+		    pCS->id = ptmpCS->id;
+		    goto AddColorSpace;
+		}
+	    }
+	}
+	/* c. None found */
+	pCS->id = NextUnregDiCsID(lastID);
+    }
+
+
+AddColorSpace:
+    if ((papColorSpaces = (XcmsColorSpace **)
+	    _XcmsPushPointerArray((XPointer *)_XcmsDIColorSpaces,
+	    (XPointer)pCS,
+	    (XPointer *)_XcmsDIColorSpacesInit)) == NULL) {
+	return(XcmsFailure);
+    }
+    _XcmsDIColorSpaces = papColorSpaces;
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/CCC.c b/libtinyX11/CCC.c
new file mode 100644
index 0000000..090b107
--- /dev/null
+++ b/libtinyX11/CCC.c
@@ -0,0 +1,286 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsCCC.c - Color Conversion Context Routines
+ *
+ *	DESCRIPTION
+ *		Routines to create, access, and free Color Conversion
+ *		Context structures.
+ *
+ *
+ */
+
+/*
+
+Copyright 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdio.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+
+
+/************************************************************************
+ *									*
+ *			PUBLIC INTERFACES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCreateCCC
+ *
+ *	SYNOPSIS
+ */
+
+XcmsCCC
+XcmsCreateCCC(
+    Display *dpy,
+    int screenNumber,
+    Visual *visual,
+    XcmsColor *clientWhitePt,
+    XcmsCompressionProc gamutCompProc,
+    XPointer gamutCompClientData,
+    XcmsWhiteAdjustProc whitePtAdjProc,
+    XPointer whitePtAdjClientData)
+/*
+ *	DESCRIPTION
+ *		Given a Display, Screen, Visual, etc., this routine creates
+ *		an appropriate Color Conversion Context.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise address of the newly
+ *		created XcmsCCC.
+ *
+ */
+{
+    XcmsCCC pDefaultCCC = XcmsDefaultCCC(dpy, screenNumber);
+    XcmsCCC newccc;
+    XcmsIntensityMap *pIMap;
+    XcmsPerScrnInfo *pNewScrnInfo;
+
+    if (pDefaultCCC == NULL ||
+	    !(newccc = (XcmsCCC) Xcalloc(1, (unsigned) sizeof(XcmsCCCRec)))) {
+	return(NULL);
+    }
+
+    /*
+     * Should inherit the following as result of a memmove():
+     *		dpy
+     *		screenNumber
+     *		pPerScrnInfo
+     */
+    memcpy((char *)newccc, (char *)pDefaultCCC, sizeof(XcmsCCCRec));
+    if (clientWhitePt) {
+	memcpy((char *)&newccc->clientWhitePt, (char *)clientWhitePt,
+		sizeof(XcmsColor));
+    }
+    if (gamutCompProc) {
+	newccc->gamutCompProc = gamutCompProc;
+    }
+    if (gamutCompClientData) {
+	newccc->gamutCompClientData = gamutCompClientData;
+    }
+    if (whitePtAdjProc) {
+	newccc->whitePtAdjProc = whitePtAdjProc;
+    }
+    if (whitePtAdjClientData) {
+	newccc->whitePtAdjClientData = whitePtAdjClientData;
+    }
+
+    /*
+     * Now check our list of per-Visual Intensity tables.
+     * If one exists replace the pPerScrnInfo.
+     */
+    if ((pIMap = _XcmsGetIntensityMap(dpy, visual)) != NULL) {
+	if (!(pNewScrnInfo = (XcmsPerScrnInfo *)
+		Xcalloc(1, (unsigned) sizeof(XcmsPerScrnInfo)))) {
+	    Xfree(newccc);
+	    return(NULL);
+	}
+	memcpy((char *)pNewScrnInfo, (char *)newccc->pPerScrnInfo,
+		sizeof(XcmsPerScrnInfo));
+	pNewScrnInfo->screenData = pIMap->screenData;
+	newccc->pPerScrnInfo = pNewScrnInfo;
+    }
+
+    /*
+     * Set visual component
+     */
+    newccc->visual = visual;
+
+    return(newccc);
+}
+
+
+/*
+ *	NAME
+ *		XcmsDefaultCCC
+ *
+ *	SYNOPSIS
+ */
+XcmsCCC
+XcmsDefaultCCC(
+    Display *dpy,
+    int screenNumber)
+/*
+ *	DESCRIPTION
+ *		Given a Display and Screen, this routine creates
+ *		returns the Screen's default Color Conversion Context.
+ *		Note that a Screen's default CCC is built with the
+ *		screen default visual.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise address of the
+ *		XcmsCCC for the Screen's default CCC.
+ *
+ */
+{
+    XcmsCCC ccc;
+
+
+    if ((screenNumber < 0) || (screenNumber >= ScreenCount(dpy))) {
+	return((XcmsCCC)NULL);
+    }
+
+    /*
+     * Check if the XcmsCCC's for each screen has been created
+     */
+    if ((XcmsCCC)dpy->cms.defaultCCCs == NULL) {
+	if (!_XcmsInitDefaultCCCs(dpy)) {
+	    return((XcmsCCC)NULL);
+	}
+    }
+
+    ccc = (XcmsCCC)dpy->cms.defaultCCCs + screenNumber;
+
+    if (!ccc->pPerScrnInfo) {
+	/*
+	 * Need to create the XcmsPerScrnInfo structure.  The
+	 * _XcmsInitScrnInfo routine will create the XcmsPerScrnInfo
+	 * structure as well as initialize its functionSet and pScreenData
+	 * components.
+	 */
+	if (!_XcmsInitScrnInfo(dpy, screenNumber)) {
+	    return((XcmsCCC)NULL);
+	}
+	return(ccc);
+    } else {
+	/*
+	 * If ccc->pPerScrnInfo->state == XcmsInitSuccess,
+	 *    then the pPerScrnInfo component has already been initialized
+	 *    therefore, just return ccc.
+	 * If ccc->pPerScrnInfo->state == XcmsInitFailure,
+	 *    then this means that we already attempted to initialize
+	 *    the pPerScrnInfo component but failed therefore stuffing
+	 *    the pPerScrnInfo component with defaults.  Just return ccc.
+	 * If ccc->pPerScrnInfo->state == XcmsInitNone,
+	 *    then attempt to initialize the pPerScrnInfo component.
+	 */
+	switch (ccc->pPerScrnInfo->state) {
+	   case XcmsInitFailure :
+	    /* fall through */
+	   case XcmsInitSuccess :
+	    return(ccc);
+	   case XcmsInitNone :
+	    /* XcmsPerScreenInfo has not been initialized */
+	    if (!_XcmsInitScrnInfo(dpy, screenNumber)) {
+		return((XcmsCCC)NULL);
+	    }
+	    return(ccc);
+	   default :
+	    return((XcmsCCC)NULL);
+	}
+    }
+}
+
+
+/*
+ *	NAME
+ *		XcmsFreeCCC
+ *
+ *	SYNOPSIS
+ */
+void
+XcmsFreeCCC(XcmsCCC ccc)
+/*
+ *	DESCRIPTION
+ *		Frees memory associated with a Color Conversion Context
+ *		that was created with XcmsCreateCCC().
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    if (ccc->dpy->cms.defaultCCCs &&
+	ccc == ((XcmsCCC)ccc->dpy->cms.defaultCCCs) + ccc->screenNumber) {
+	/* do not allow clients to free DefaultCCC's */
+	return;
+    }
+
+    /*
+     * Note that XcmsPerScrnInfo sub-structures are freed here only if
+     * they are for visuals that have per-Visual intensity tables.
+     * Otherwise the XcmsPerScrnInfo structure is being shared!
+     * For the latter, there is only one allocated per Screen and it just
+     * so happens * that we place its initial reference is placed in the
+     * 	default CCC.  The routine _XcmsFreeDefaultCCCs frees them.
+     */
+    if (_XcmsGetIntensityMap(ccc->dpy, ccc->visual) != NULL) {
+	Xfree(ccc->pPerScrnInfo);
+    }
+
+    Xfree(ccc);
+}
diff --git a/libtinyX11/Cmap.h b/libtinyX11/Cmap.h
new file mode 100644
index 0000000..062b538
--- /dev/null
+++ b/libtinyX11/Cmap.h
@@ -0,0 +1,10 @@
+
+#ifndef _CMAP_H_
+#define _CMAP_H_
+
+extern void
+_XcmsDeleteCmapRec(
+    Display *dpy,
+    Colormap cmap);
+
+#endif /* _CMAP_H_ */
diff --git a/libtinyX11/Cv.h b/libtinyX11/Cv.h
new file mode 100644
index 0000000..47e2872
--- /dev/null
+++ b/libtinyX11/Cv.h
@@ -0,0 +1,190 @@
+
+#ifndef _CV_H_
+#define _CV_H_
+
+#include <X11/Xcms.h>
+/* variables */
+extern const char      _XcmsCIEXYZ_prefix[];
+extern const char      _XcmsCIEuvY_prefix[];
+extern const char      _XcmsCIExyY_prefix[];
+extern const char      _XcmsCIELab_prefix[];
+extern const char      _XcmsCIELuv_prefix[];
+extern const char      _XcmsTekHVC_prefix[];
+extern const char      _XcmsRGBi_prefix[];
+extern const char      _XcmsRGB_prefix[];
+
+extern XcmsColorSpace  XcmsUNDEFINEDColorSpace;
+extern XcmsColorSpace  XcmsTekHVCColorSpace;
+extern XcmsColorSpace  XcmsCIEXYZColorSpace;
+extern XcmsColorSpace  XcmsCIEuvYColorSpace;
+extern XcmsColorSpace  XcmsCIExyYColorSpace;
+extern XcmsColorSpace  XcmsCIELabColorSpace;
+extern XcmsColorSpace  XcmsCIELuvColorSpace;
+extern XcmsColorSpace  XcmsRGBColorSpace;
+extern XcmsColorSpace  XcmsRGBiColorSpace;
+
+extern XcmsColorSpace  *_XcmsDIColorSpacesInit[];
+extern XcmsColorSpace  **_XcmsDIColorSpaces;
+
+extern XcmsColorSpace  *_XcmsDDColorSpacesInit[];
+extern XcmsColorSpace  **_XcmsDDColorSpaces;
+
+extern XcmsFunctionSet XcmsLinearRGBFunctionSet;
+
+extern XcmsFunctionSet *_XcmsSCCFuncSetsInit[];
+extern XcmsFunctionSet **_XcmsSCCFuncSets;
+
+extern XcmsRegColorSpaceEntry _XcmsRegColorSpaces[];
+
+/* functions */
+extern XPointer *
+_XcmsCopyPointerArray(
+    XPointer *pap);
+extern void
+_XcmsFreePointerArray(
+    XPointer *pap);
+extern XPointer *
+_XcmsPushPointerArray(
+    XPointer *pap,
+    XPointer p,
+    XPointer *papNoFree);
+extern Status
+_XcmsCIEXYZ_ValidSpec(
+    XcmsColor *pColor);
+extern Status
+_XcmsCIEuvY_ValidSpec(
+    XcmsColor *pColor);
+extern int
+_XcmsTekHVC_CheckModify(
+    XcmsColor *pColor);
+
+extern Status
+_XcmsTekHVCQueryMaxVCRGB(
+    XcmsCCC     ccc,
+    XcmsFloat   hue,
+    XcmsColor   *pColor_return,
+    XcmsRGBi    *pRGB_return);
+extern Status
+_XcmsCIELabQueryMaxLCRGB(
+    XcmsCCC     ccc,
+    XcmsFloat   hue,                /* hue in radians */
+    XcmsColor   *pColor_return,
+    XcmsRGBi    *pRGB_return);
+extern Status
+_XcmsConvertColorsWithWhitePt(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    XcmsColor *pWhitePt,
+    unsigned int nColors,
+    XcmsColorFormat newFormat,
+    Bool *pCompressed);
+
+extern Status
+_XcmsDIConvertColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    XcmsColor *pWhitePt,
+    unsigned int nColors,
+    XcmsColorFormat newFormat);
+extern Status
+_XcmsDDConvertColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors,
+    XcmsColorFormat newFormat,
+    Bool *pCompressed);
+extern XcmsColorFormat
+_XcmsRegFormatOfPrefix(
+    _Xconst char *prefix);
+extern void
+_XColor_to_XcmsRGB(
+    XcmsCCC ccc,
+    XColor *pXColors,
+    XcmsColor *pColors,
+    unsigned int nColors);
+extern Status
+_XcmsSetGetColor(
+    Status (*xColorProc)(
+        Display*            /* display */,
+        Colormap            /* colormap */,
+        XColor*             /* screen_in_out */),
+    Display *dpy,
+    Colormap cmap,
+    XcmsColor *pColors_in_out,
+    XcmsColorFormat result_format,
+    Bool *pCompressed);
+extern Status
+_XcmsSetGetColors(
+    Status (*xColorProc)(
+        Display*            /* display */,
+        Colormap            /* colormap */,
+        XColor*             /* screen_in_out */,
+        int                 /* nColors */),
+    Display *dpy,
+    Colormap cmap,
+    XcmsColor *pColors_in_out,
+    int nColors,
+    XcmsColorFormat result_format,
+    Bool *pCompressed);
+extern Status
+_XcmsCIELuvQueryMaxLCRGB(
+    XcmsCCC     ccc,
+    XcmsFloat   hue,            /* hue in radians */
+    XcmsColor   *pColor_return,
+    XcmsRGBi    *pRGB_return);
+
+extern XcmsIntensityMap *
+_XcmsGetIntensityMap(
+    Display *dpy,
+    Visual *visual);
+extern int
+_XcmsInitDefaultCCCs(
+    Display *dpy);
+extern int
+_XcmsInitScrnInfo(
+    register Display *dpy,
+    int screenNumber);
+extern XcmsCmapRec *
+_XcmsCopyCmapRecAndFree(
+    Display *dpy,
+    Colormap src_cmap,
+    Colormap copy_cmap);
+extern void
+_XcmsCopyISOLatin1Lowered(
+    char *dst,
+    const char *src);
+extern int
+_XcmsEqualWhitePts(
+    XcmsCCC ccc, XcmsColor *pWhitePt1, XcmsColor *pWhitePt2);
+extern int
+_XcmsLRGB_InitScrnDefault(
+    Display *dpy,
+    int screenNumber,
+    XcmsPerScrnInfo *pPerScrnInfo);
+extern void
+_XcmsFreeIntensityMaps(
+    Display *dpy);
+extern int
+_XcmsGetProperty(
+    Display *pDpy,
+    Window  w,
+    Atom property,
+    int             *pFormat,
+    unsigned long   *pNItems,
+    unsigned long   *pNBytes,
+    char            **pValue);
+extern unsigned long
+_XcmsGetElement(
+    int             format,
+    char            **pValue,
+    unsigned long   *pCount);
+extern void
+_XcmsUnresolveColor(
+    XcmsCCC ccc,
+    XcmsColor *pColor);
+extern void
+_XcmsResolveColor(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColor);
+
+#endif /* _CV_H_ */
diff --git a/libtinyX11/CvColW.c b/libtinyX11/CvColW.c
new file mode 100644
index 0000000..4aabded
--- /dev/null
+++ b/libtinyX11/CvColW.c
@@ -0,0 +1,141 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *
+ *	NAME
+ *		XcmsCvColW.c
+ *
+ *	DESCRIPTION
+ *		<overall description of what the package does>
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+
+/************************************************************************
+ *									*
+ *			 API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+
+/*
+ *	NAME
+ *		_XcmsConvertColorsWithWhitePt - Convert XcmsColor structures
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsConvertColorsWithWhitePt(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    XcmsColor *pWhitePt,
+    unsigned int nColors,
+    XcmsColorFormat newFormat,
+    Bool *pCompressed)
+/*
+ *	DESCRIPTION
+ *		Convert XcmsColor structures between device-independent
+ *		and/or device-dependent formats but allowing the calling
+ *		routine to specify the white point to be associated
+ *		with the color specifications (overriding
+ *		ccc->clientWhitePt).
+ *
+ *		This routine has been provided for use in white point
+ *		adjustment routines.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded without gamut compression,
+ *		XcmsSuccessWithCompression if succeeded with gamut
+ *			compression.
+ *
+ */
+{
+    if (ccc == NULL || pColors_in_out == NULL ||
+	    pColors_in_out->format == XcmsUndefinedFormat) {
+	return(XcmsFailure);
+    }
+
+    if (nColors == 0 || pColors_in_out->format == newFormat) {
+	/* do nothing */
+	return(XcmsSuccess);
+    }
+
+    if (XCMS_DI_ID(pColors_in_out->format) && XCMS_DI_ID(newFormat)) {
+	/*
+	 * Device-Independent to Device-Independent Conversion
+	 */
+	return(_XcmsDIConvertColors(ccc, pColors_in_out, pWhitePt, nColors,
+		newFormat));
+    }
+    if (XCMS_DD_ID(pColors_in_out->format) && XCMS_DD_ID(newFormat)) {
+	/*
+	 * Device-Dependent to Device-Dependent Conversion
+	 */
+	return(_XcmsDDConvertColors(ccc, pColors_in_out, nColors, newFormat,
+		pCompressed));
+    }
+
+    /*
+     * Otherwise we have:
+     *    1. Device-Independent to Device-Dependent Conversion
+     *		OR
+     *    2. Device-Dependent to Device-Independent Conversion
+     */
+
+    if (XCMS_DI_ID(pColors_in_out->format)) {
+	/*
+	 *    1. Device-Independent to Device-Dependent Conversion
+	 */
+	/* First convert to CIEXYZ */
+	if (_XcmsDIConvertColors(ccc, pColors_in_out, pWhitePt, nColors,
+		XcmsCIEXYZFormat) == XcmsFailure) {
+	    return(XcmsFailure);
+	}
+	/* Then convert to DD Format */
+	return(_XcmsDDConvertColors(ccc, pColors_in_out, nColors, newFormat,
+		pCompressed));
+    } else {
+	/*
+	 *    2. Device-Dependent to Device-Independent Conversion
+	 */
+	/* First convert to CIEXYZ */
+	if (_XcmsDDConvertColors(ccc, pColors_in_out, nColors,
+		XcmsCIEXYZFormat, pCompressed) == XcmsFailure) {
+	    return(XcmsFailure);
+	}
+	/* Then convert to DI Format */
+	return(_XcmsDIConvertColors(ccc, pColors_in_out, pWhitePt, nColors,
+		newFormat));
+    }
+}
diff --git a/libtinyX11/CvCols.c b/libtinyX11/CvCols.c
new file mode 100644
index 0000000..ed35826
--- /dev/null
+++ b/libtinyX11/CvCols.c
@@ -0,0 +1,1030 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsCvCols.c
+ *
+ *	DESCRIPTION
+ *		Xcms API routine that converts between the
+ *		device-independent color spaces.
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *      LOCAL DEFINES
+ */
+#define	DD_FORMAT	0x01
+#define	DI_FORMAT	0x02
+#define	MIX_FORMAT	0x04
+#ifndef MAX
+#  define MAX(x,y) ((x) > (y) ? (x) : (y))
+#endif
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		EqualCIEXYZ
+ *
+ *	SYNOPSIS
+ */
+static int
+EqualCIEXYZ(
+    XcmsColor *p1, XcmsColor *p2)
+/*
+ *	DESCRIPTION
+ *		Compares two XcmsColor structures that are in XcmsCIEXYZFormat
+ *
+ *	RETURNS
+ *		Returns 1 if equal; 0 otherwise.
+ *
+ */
+{
+    if (p1->format != XcmsCIEXYZFormat || p2->format != XcmsCIEXYZFormat) {
+	return(0);
+    }
+    if ((p1->spec.CIEXYZ.X != p2->spec.CIEXYZ.X)
+	    || (p1->spec.CIEXYZ.Y != p2->spec.CIEXYZ.Y)
+	    || (p1->spec.CIEXYZ.Z != p2->spec.CIEXYZ.Z)) {
+	return(0);
+    }
+    return(1);
+}
+
+
+/*
+ *	NAME
+ *		XcmsColorSpace
+ *
+ *	SYNOPSIS
+ */
+static XcmsColorSpace *
+ColorSpaceOfID(
+    XcmsCCC ccc,
+    XcmsColorFormat	id)
+/*
+ *	DESCRIPTION
+ *		Returns a pointer to the color space structure
+ *		(XcmsColorSpace) associated with the specified color space
+ *		ID.
+ *
+ *	RETURNS
+ *		Pointer to matching XcmsColorSpace structure if found;
+ *		otherwise NULL.
+ */
+{
+    XcmsColorSpace	**papColorSpaces;
+
+    if (ccc == NULL) {
+	return(NULL);
+    }
+
+    /*
+     * First try Device-Independent color spaces
+     */
+    papColorSpaces = _XcmsDIColorSpaces;
+    if (papColorSpaces != NULL) {
+	while (*papColorSpaces != NULL) {
+	    if ((*papColorSpaces)->id == id) {
+		return(*papColorSpaces);
+	    }
+	    papColorSpaces++;
+	}
+    }
+
+    /*
+     * Next try Device-Dependent color spaces
+     */
+    papColorSpaces = ((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->DDColorSpaces;
+    if (papColorSpaces != NULL) {
+	while (*papColorSpaces != NULL) {
+	    if ((*papColorSpaces)->id == id) {
+		return(*papColorSpaces);
+	    }
+	    papColorSpaces++;
+	}
+    }
+
+    return(NULL);
+}
+
+
+/*
+ *	NAME
+ *		ValidDIColorSpaceID
+ *
+ *	SYNOPSIS
+ */
+static int
+ValidDIColorSpaceID(
+    XcmsColorFormat id)
+/*
+ *	DESCRIPTION
+ *		Determines if the specified color space ID is a valid
+ *		Device-Independent color space in the specified Color
+ *		Conversion Context.
+ *
+ *	RETURNS
+ *		Returns zero if not valid; otherwise non-zero.
+ */
+{
+    XcmsColorSpace **papRec;
+    papRec = _XcmsDIColorSpaces;
+    if (papRec != NULL) {
+	while (*papRec != NULL) {
+	    if ((*papRec)->id == id) {
+		return(1);
+	    }
+	    papRec++;
+	}
+    }
+    return(0);
+}
+
+
+/*
+ *	NAME
+ *		ValidDDColorSpaceID
+ *
+ *	SYNOPSIS
+ */
+static int
+ValidDDColorSpaceID(
+    XcmsCCC ccc,
+    XcmsColorFormat id)
+/*
+ *	DESCRIPTION
+ *		Determines if the specified color space ID is a valid
+ *		Device-Dependent color space in the specified Color
+ *		Conversion Context.
+ *
+ *	RETURNS
+ *		Returns zero if not valid; otherwise non-zero.
+ */
+{
+    XcmsColorSpace **papRec;
+
+    if (ccc->pPerScrnInfo->state != XcmsInitNone) {
+	papRec = ((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->DDColorSpaces;
+	while (*papRec != NULL) {
+	    if ((*papRec)->id == id) {
+		return(1);
+	    }
+	    papRec++;
+	}
+    }
+    return(0);
+}
+
+
+/*
+ *	NAME
+ *		ConvertMixedColors - Convert XcmsColor structures
+ *
+ *	SYNOPSIS
+ */
+static Status
+ConvertMixedColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    XcmsColor *pWhitePt,
+    unsigned int nColors,
+    XcmsColorFormat targetFormat,
+    unsigned char format_flag)
+/*
+ *	DESCRIPTION
+ *		This routine will only convert the following types of
+ *		batches:
+ *			DI to DI
+ *			DD to DD
+ *			DD to CIEXYZ
+ *		In other words, it will not convert the following types of
+ *		batches:
+ *			DI to DD
+ *			DD to DI(not CIEXYZ)
+ *
+ *		format_flag:
+ *		    0x01 : convert Device-Dependent only specifications to the
+ *			target format.
+ *		    0x02 : convert Device-Independent only specifications to the
+ *			target format.
+ *		    0x03 : convert all specifications to the target format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if none of the color specifications were
+ *			compressed in the conversion process
+ *		XcmsSuccessWithCompression if at least one of the
+ *			color specifications were compressed in the
+ *			conversion process.
+ *
+ */
+{
+    XcmsColor *pColor, *pColors_start;
+    XcmsColorFormat format;
+    Status retval_tmp;
+    Status retval = XcmsSuccess;
+    unsigned int iColors;
+    unsigned int nBatch;
+
+    /*
+     * Convert array of mixed color specifications in batches of
+     * contiguous formats to the target format
+     */
+    iColors = 0;
+    while (iColors < nColors) {
+	/*
+	 * Find contiguous array of color specifications with the
+	 * same format
+	 */
+	pColor = pColors_start = pColors_in_out + iColors;
+	format = pColors_start->format;
+	nBatch = 0;
+	while (iColors < nColors && pColor->format == format) {
+		pColor++;
+		nBatch++;
+		iColors++;
+	}
+	if (format != targetFormat) {
+	    /*
+	     * Need to convert this batch from current format to target format.
+	     */
+	    if (XCMS_DI_ID(format) && (format_flag & DI_FORMAT) &&
+		XCMS_DI_ID(targetFormat)) {
+		/*
+		 * DI->DI
+		 *
+		 * Format of interest is Device-Independent,
+		 * This batch contains Device-Independent specifications, and
+		 * the Target format is Device-Independent.
+		 */
+		retval_tmp = _XcmsDIConvertColors(ccc, pColors_start, pWhitePt,
+			nBatch, targetFormat);
+	    } else if (XCMS_DD_ID(format) && (format_flag & DD_FORMAT) &&
+		    (targetFormat == XcmsCIEXYZFormat)) {
+		/*
+		 * DD->CIEXYZ
+		 *
+		 * Format of interest is Device-Dependent,
+		 * This batch contains Device-Dependent specifications, and
+		 * the Target format is CIEXYZ.
+		 *
+		 * Since DD->CIEXYZ we can use NULL instead of pCompressed.
+		 */
+		if ((ccc->whitePtAdjProc != NULL) && !_XcmsEqualWhitePts(ccc,
+			pWhitePt, ScreenWhitePointOfCCC(ccc))) {
+		    /*
+		     * Need to call WhiteAdjustProc (Screen White Point to
+		     *   White Point).
+		     */
+		    retval_tmp = (*ccc->whitePtAdjProc)(ccc,
+			    ScreenWhitePointOfCCC(ccc), pWhitePt,
+			    XcmsCIEXYZFormat, pColors_start, nBatch,
+			    (Bool *)NULL);
+		} else {
+		    retval_tmp = _XcmsDDConvertColors(ccc, pColors_start,
+			    nBatch, XcmsCIEXYZFormat, (Bool *)NULL);
+		}
+	    } else if (XCMS_DD_ID(format) && (format_flag & DD_FORMAT) &&
+		    XCMS_DD_ID(targetFormat)) {
+		/*
+		 * DD->DD(not CIEXYZ)
+		 *
+		 * Format of interest is Device-Dependent,
+		 * This batch contains Device-Dependent specifications, and
+		 * the Target format is Device-Dependent and not CIEXYZ.
+		 */
+		retval_tmp = _XcmsDDConvertColors(ccc, pColors_start, nBatch,
+			targetFormat, (Bool *)NULL);
+	    } else {
+		/*
+		 * This routine is called for the wrong reason.
+		 */
+		return(XcmsFailure);
+	    }
+	    if (retval_tmp == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	    retval = MAX(retval, retval_tmp);
+	}
+    }
+    return(retval);
+}
+
+
+/************************************************************************
+ *									*
+ *			 API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsEqualWhitePts
+ *
+ *	SYNOPSIS
+ */
+int
+_XcmsEqualWhitePts(XcmsCCC ccc, XcmsColor *pWhitePt1, XcmsColor *pWhitePt2)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		Returns 0 if not equal; otherwise 1.
+ *
+ */
+{
+    XcmsColor tmp1, tmp2;
+
+    memcpy((char *)&tmp1, (char *)pWhitePt1, sizeof(XcmsColor));
+    memcpy((char *)&tmp2, (char *)pWhitePt2, sizeof(XcmsColor));
+
+    if (tmp1.format != XcmsCIEXYZFormat) {
+	if (_XcmsDIConvertColors(ccc, &tmp1, (XcmsColor *) NULL, 1,
+		XcmsCIEXYZFormat)==0) {
+	    return(0);
+	}
+    }
+
+    if (tmp2.format != XcmsCIEXYZFormat) {
+	if (_XcmsDIConvertColors(ccc, &tmp2, (XcmsColor *) NULL, 1,
+		XcmsCIEXYZFormat)==0) {
+	    return(0);
+	}
+    }
+
+    return (EqualCIEXYZ(&tmp1, &tmp2));
+}
+
+
+/*
+ *	NAME
+ *		_XcmsDIConvertColors - Convert XcmsColor structures
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsDIConvertColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    XcmsColor *pWhitePt,
+    unsigned int nColors,
+    XcmsColorFormat newFormat)
+/*
+ *	DESCRIPTION
+ *		Convert XcmsColor structures to another Device-Independent
+ *		form.
+ *
+ *		Here are some assumptions that this routine makes:
+ *		1. The calling routine has already checked if
+ *		    pColors_in_out->format == newFormat, therefore
+ *		    there is no need to check again here.
+ *		2. The calling routine has already checked nColors,
+ *		    therefore this routine assumes nColors > 0.
+ *		3. The calling routine may want to convert only between
+ *			CIExyY <-> CIEXYZ <-> CIEuvY
+ *		    therefore, this routine allows pWhitePt to equal NULL.
+ *
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsColorSpace *pFrom, *pTo;
+    XcmsDIConversionProc *src_to_CIEXYZ, *src_from_CIEXYZ;
+    XcmsDIConversionProc *dest_to_CIEXYZ, *dest_from_CIEXYZ;
+    XcmsDIConversionProc *to_CIEXYZ_stop, *from_CIEXYZ_start;
+    XcmsDIConversionProc *tmp;
+
+    /*
+     * Allow pWhitePt to equal NULL.  This appropriate when converting
+     *    anywhere between:
+     *		CIExyY <-> CIEXYZ <-> CIEuvY
+     */
+
+    if (pColors_in_out == NULL ||
+	    !ValidDIColorSpaceID(pColors_in_out->format) ||
+	    !ValidDIColorSpaceID(newFormat)) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Get a handle on the function list for the current specification format
+     */
+    if ((pFrom = ColorSpaceOfID(ccc, pColors_in_out->format))
+	    == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Get a handle on the function list for the new specification format
+     */
+    if ((pTo = ColorSpaceOfID(ccc, newFormat)) == NULL) {
+	return(XcmsFailure);
+    }
+
+    src_to_CIEXYZ = pFrom->to_CIEXYZ;
+    src_from_CIEXYZ = pFrom->from_CIEXYZ;
+    dest_to_CIEXYZ = pTo->to_CIEXYZ;
+    dest_from_CIEXYZ = pTo->from_CIEXYZ;
+
+    if (pTo->inverse_flag && pFrom->inverse_flag) {
+	/*
+	 * Find common function pointers
+	 */
+	for (to_CIEXYZ_stop = src_to_CIEXYZ; *to_CIEXYZ_stop; to_CIEXYZ_stop++){
+	    for (tmp = dest_to_CIEXYZ; *tmp; tmp++) {
+		if (*to_CIEXYZ_stop == *tmp) {
+		    goto Continue;
+		}
+	    }
+	}
+
+Continue:
+
+	/*
+	 * Execute the functions to CIEXYZ, stopping short as necessary
+	 */
+	while (src_to_CIEXYZ != to_CIEXYZ_stop) {
+	    if ((*src_to_CIEXYZ++)(ccc, pWhitePt, pColors_in_out,
+		    nColors) == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	}
+
+	/*
+	 * Determine where to start on the from_CIEXYZ path.
+	 */
+	from_CIEXYZ_start = dest_from_CIEXYZ;
+	tmp = src_from_CIEXYZ;
+	while ((*from_CIEXYZ_start == *tmp) && (*from_CIEXYZ_start != NULL)) {
+	    from_CIEXYZ_start++;
+	    tmp++;
+	}
+
+    } else {
+	/*
+	 * The function in at least one of the Color Spaces are not
+	 * complementary, i.e.,
+	 *	for an i, 0 <= i < n elements
+	 *	from_CIEXYZ[i] is not the inverse of to_CIEXYZ[i]
+	 *
+	 * Execute the functions all the way to CIEXYZ
+	 */
+	while (*src_to_CIEXYZ) {
+	    if ((*src_to_CIEXYZ++)(ccc, pWhitePt, pColors_in_out,
+		    nColors) == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	}
+
+	/*
+	 * Determine where to start on the from_CIEXYZ path.
+	 */
+	from_CIEXYZ_start = dest_from_CIEXYZ;
+    }
+
+
+    /*
+     * Execute the functions from CIEXYZ.
+     */
+    while (*from_CIEXYZ_start) {
+	if ((*from_CIEXYZ_start++)(ccc, pWhitePt, pColors_in_out,
+		nColors) == XcmsFailure) {
+	    return(XcmsFailure);
+	}
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsDDConvertColors - Convert XcmsColor structures
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsDDConvertColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors,
+    XcmsColorFormat newFormat,
+    Bool *pCompressed)
+/*
+ *	DESCRIPTION
+ *		Convert XcmsColor structures:
+ *
+ *		1. From CIEXYZ to Device-Dependent formats (typically RGB and
+ *			RGBi),
+ *		    or
+ *		2. Between Device-Dependent formats (typically RGB and RGBi).
+ *
+ *		Assumes that these specifications have already been white point
+ *		adjusted if necessary from Client White Point to Screen
+ *		White Point.  Therefore, the white point now associated
+ *		with the specifications is the Screen White Point.
+ *
+ *		pCompressed may be NULL.  If so this indicates that the
+ *		calling routine is not interested in knowing exactly which
+ *		color was compressed, if any.
+ *
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if none of the color specifications were
+ *			compressed in the conversion process
+ *		XcmsSuccessWithCompression if at least one of the
+ *			color specifications were compressed in the
+ *			conversion process.
+ *
+ */
+{
+    XcmsColorSpace *pFrom, *pTo;
+    XcmsDDConversionProc *src_to_CIEXYZ, *src_from_CIEXYZ;
+    XcmsDDConversionProc *dest_to_CIEXYZ, *dest_from_CIEXYZ;
+    XcmsDDConversionProc *from_CIEXYZ_start, *to_CIEXYZ_stop;
+    XcmsDDConversionProc *tmp;
+    int	retval;
+    int hasCompressed = 0;
+
+    if (ccc == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    if (nColors == 0 || pColors_in_out->format == newFormat) {
+	/* do nothing */
+	return(XcmsSuccess);
+    }
+
+    if (((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet) == NULL) {
+	return(XcmsFailure);	/* hmm, an internal error? */
+    }
+
+    /*
+     * Its ok if pColors_in_out->format == XcmsCIEXYZFormat
+     *	or
+     * if newFormat == XcmsCIEXYZFormat
+     */
+    if ( !( ValidDDColorSpaceID(ccc, pColors_in_out->format)
+	    ||
+	    (pColors_in_out->format == XcmsCIEXYZFormat))
+	 ||
+	 !(ValidDDColorSpaceID(ccc, newFormat)
+	    ||
+	    newFormat == XcmsCIEXYZFormat)) {
+	return(XcmsFailure);
+    }
+
+    if ((pFrom = ColorSpaceOfID(ccc, pColors_in_out->format)) == NULL){
+	return(XcmsFailure);
+    }
+
+    if ((pTo = ColorSpaceOfID(ccc, newFormat)) == NULL) {
+	return(XcmsFailure);
+    }
+
+    src_to_CIEXYZ = (XcmsDDConversionProc *)pFrom->to_CIEXYZ;
+    src_from_CIEXYZ = (XcmsDDConversionProc *)pFrom->from_CIEXYZ;
+    dest_to_CIEXYZ = (XcmsDDConversionProc *)pTo->to_CIEXYZ;
+    dest_from_CIEXYZ = (XcmsDDConversionProc *)pTo->from_CIEXYZ;
+
+    if (pTo->inverse_flag && pFrom->inverse_flag) {
+	/*
+	 * Find common function pointers
+	 */
+	for (to_CIEXYZ_stop = src_to_CIEXYZ; *to_CIEXYZ_stop; to_CIEXYZ_stop++){
+	    for (tmp = dest_to_CIEXYZ; *tmp; tmp++) {
+		if (*to_CIEXYZ_stop == *tmp) {
+		    goto Continue;
+		}
+	    }
+	}
+Continue:
+
+	/*
+	 * Execute the functions
+	 */
+	while (src_to_CIEXYZ != to_CIEXYZ_stop) {
+	    retval = (*src_to_CIEXYZ++)(ccc, pColors_in_out, nColors,
+		    pCompressed);
+	    if (retval == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	    hasCompressed |= (retval == XcmsSuccessWithCompression);
+	}
+
+	/*
+	 * Determine where to start on the from_CIEXYZ path.
+	 */
+	from_CIEXYZ_start = dest_from_CIEXYZ;
+	tmp = src_from_CIEXYZ;
+	while ((*from_CIEXYZ_start == *tmp) && (*from_CIEXYZ_start != NULL)) {
+	    from_CIEXYZ_start++;
+	    tmp++;
+	}
+
+    } else {
+	/*
+	 * The function in at least one of the Color Spaces are not
+	 * complementary, i.e.,
+	 *	for an i, 0 <= i < n elements
+	 *	from_CIEXYZ[i] is not the inverse of to_CIEXYZ[i]
+	 *
+	 * Execute the functions all the way to CIEXYZ
+	 */
+	while (*src_to_CIEXYZ) {
+	    retval = (*src_to_CIEXYZ++)(ccc, pColors_in_out, nColors,
+		    pCompressed);
+	    if (retval == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	    hasCompressed |= (retval == XcmsSuccessWithCompression);
+	}
+
+	/*
+	 * Determine where to start on the from_CIEXYZ path.
+	 */
+	from_CIEXYZ_start = dest_from_CIEXYZ;
+    }
+
+    while (*from_CIEXYZ_start) {
+	retval = (*from_CIEXYZ_start++)(ccc, pColors_in_out, nColors,
+		pCompressed);
+	if (retval == XcmsFailure) {
+	    return(XcmsFailure);
+	}
+	hasCompressed |= (retval == XcmsSuccessWithCompression);
+    }
+
+    return(hasCompressed ? XcmsSuccessWithCompression : XcmsSuccess);
+}
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsConvertColors - Convert XcmsColor structures
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsConvertColors(
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors,
+    XcmsColorFormat targetFormat,
+    Bool *pCompressed)
+/*
+ *	DESCRIPTION
+ *		Convert XcmsColor structures to another format
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded without gamut compression,
+ *		XcmsSuccessWithCompression if succeeded with gamut
+ *			compression.
+ *
+ */
+{
+    XcmsColor clientWhitePt;
+    XcmsColor Color1;
+    XcmsColor *pColors_tmp;
+    int callWhiteAdjustProc = 0;
+    XcmsColorFormat format;
+    Status retval;
+    unsigned char contents_flag = 0x00;
+    unsigned int iColors;
+
+    if (ccc == NULL || pColors_in_out == NULL ||
+		!(ValidDIColorSpaceID(targetFormat) ||
+		ValidDDColorSpaceID(ccc, targetFormat))) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Check formats in color specification array
+     */
+    format = pColors_in_out->format;
+    for (pColors_tmp = pColors_in_out, iColors = nColors; iColors; pColors_tmp++, iColors--) {
+	if (!(ValidDIColorSpaceID(pColors_tmp->format) ||
+		ValidDDColorSpaceID(ccc, pColors_tmp->format))) {
+	    return(XcmsFailure);
+	}
+	if (XCMS_DI_ID(pColors_tmp->format)) {
+	    contents_flag |= DI_FORMAT;
+	} else {
+	    contents_flag |= DD_FORMAT;
+	}
+	if (pColors_tmp->format != format) {
+	    contents_flag |= MIX_FORMAT;
+	}
+    }
+
+    /*
+     * Check if we need the Client White Point.
+     */
+    if ((contents_flag & DI_FORMAT) || XCMS_DI_ID(targetFormat)) {
+	/* To proceed, we need to get the Client White Point */
+	memcpy((char *)&clientWhitePt, (char *)&ccc->clientWhitePt,
+	       sizeof(XcmsColor));
+	if (clientWhitePt.format == XcmsUndefinedFormat) {
+	    /*
+	     * Client White Point is undefined, therefore set to the Screen
+	     *   White Point.
+	     * Since Client White Point == Screen White Point, WhiteAdjustProc
+	     *   is not called.
+	     */
+	    memcpy((char *)&clientWhitePt,
+		   (char *)&ccc->pPerScrnInfo->screenWhitePt,
+		   sizeof(XcmsColor));
+	} else if ((ccc->whitePtAdjProc != NULL) && !_XcmsEqualWhitePts(ccc,
+		&clientWhitePt, ScreenWhitePointOfCCC(ccc))) {
+	    /*
+	     * Client White Point != Screen White Point, and WhiteAdjustProc
+	     *   is not NULL, therefore, will need to call it when
+	     *   converting between DI and DD specifications.
+	     */
+	    callWhiteAdjustProc = 1;
+	}
+    }
+
+    /*
+     * Make copy of array of color specifications
+     */
+    if (nColors > 1) {
+	pColors_tmp = (XcmsColor *) Xmalloc(nColors * sizeof(XcmsColor));
+    } else {
+	pColors_tmp = &Color1;
+    }
+    memcpy((char *)pColors_tmp, (char *)pColors_in_out,
+	   nColors * sizeof(XcmsColor));
+
+    /*
+     * zero out pCompressed
+     */
+    if (pCompressed) {
+	bzero((char *)pCompressed, nColors * sizeof(Bool));
+    }
+
+    if (contents_flag == DD_FORMAT || contents_flag == DI_FORMAT) {
+	/*
+	 * ENTIRE ARRAY IS IN ONE FORMAT.
+	 */
+	if (XCMS_DI_ID(format) && XCMS_DI_ID(targetFormat)) {
+	    /*
+	     * DI-to-DI only conversion
+	     */
+	    retval = _XcmsDIConvertColors(ccc, pColors_tmp,
+		    &clientWhitePt, nColors, targetFormat);
+	} else if (XCMS_DD_ID(format) && XCMS_DD_ID(targetFormat)) {
+	    /*
+	     * DD-to-DD only conversion
+	     *   Since DD->DD there will be no compressed thus we can
+	     *   pass NULL instead of pCompressed.
+	     */
+	    retval = _XcmsDDConvertColors(ccc, pColors_tmp, nColors,
+		    targetFormat, (Bool *)NULL);
+	} else {
+	    /*
+	     * Otherwise we have:
+	     *    1. Device-Independent to Device-Dependent Conversion
+	     *		OR
+	     *    2. Device-Dependent to Device-Independent Conversion
+	     *
+	     *  We need to go from oldFormat -> CIEXYZ -> targetFormat
+	     *	adjusting for white points as necessary.
+	     */
+
+	    if (XCMS_DI_ID(format)) {
+		/*
+		 *    1. Device-Independent to Device-Dependent Conversion
+		 */
+		if (callWhiteAdjustProc) {
+		    /*
+		     * White Point Adjustment
+		     *		Client White Point to Screen White Point
+		     */
+		    retval = (*ccc->whitePtAdjProc)(ccc, &clientWhitePt,
+			    ScreenWhitePointOfCCC(ccc), targetFormat,
+			    pColors_tmp, nColors, pCompressed);
+		} else {
+		    if (_XcmsDIConvertColors(ccc, pColors_tmp,
+			    &clientWhitePt, nColors, XcmsCIEXYZFormat)
+			    == XcmsFailure) {
+			goto Failure;
+		    }
+		    retval = _XcmsDDConvertColors(ccc, pColors_tmp, nColors,
+			    targetFormat, pCompressed);
+		}
+	    } else {
+		/*
+		 *    2. Device-Dependent to Device-Independent Conversion
+		 */
+		if (callWhiteAdjustProc) {
+		    /*
+		     * White Point Adjustment
+		     *		Screen White Point to Client White Point
+		     */
+		    retval = (*ccc->whitePtAdjProc)(ccc,
+			    ScreenWhitePointOfCCC(ccc), &clientWhitePt,
+			    targetFormat, pColors_tmp, nColors, pCompressed);
+		} else {
+		    /*
+		     * Since DD->CIEXYZ, no compression takes place therefore
+		     * we can pass NULL instead of pCompressed.
+		     */
+		    if (_XcmsDDConvertColors(ccc, pColors_tmp, nColors,
+			    XcmsCIEXYZFormat, (Bool *)NULL) == XcmsFailure) {
+			goto Failure;
+		    }
+		    retval = _XcmsDIConvertColors(ccc, pColors_tmp,
+			    &clientWhitePt, nColors, targetFormat);
+		}
+	    }
+	}
+    } else {
+	/*
+	 * ARRAY HAS MIXED FORMATS.
+	 */
+	if ((contents_flag == (DI_FORMAT | MIX_FORMAT)) &&
+		XCMS_DI_ID(targetFormat)) {
+	    /*
+	     * Convert from DI to DI in batches of contiguous formats
+	     *
+	     * Because DI->DI, WhiteAdjustProc not called.
+	     */
+	    retval = ConvertMixedColors(ccc, pColors_tmp, &clientWhitePt,
+		    nColors, targetFormat, (unsigned char)DI_FORMAT);
+	} else if ((contents_flag == (DD_FORMAT | MIX_FORMAT)) &&
+		XCMS_DD_ID(targetFormat)) {
+	    /*
+	     * Convert from DD to DD in batches of contiguous formats
+	     *
+	     * Because DD->DD, WhiteAdjustProc not called.
+	     */
+	    retval = ConvertMixedColors(ccc, pColors_tmp,
+		    (XcmsColor *)NULL, nColors, targetFormat,
+		    (unsigned char)DD_FORMAT);
+	} else if (XCMS_DI_ID(targetFormat)) {
+	    /*
+	     * We need to convert from DI-to-DI and DD-to-DI, therefore
+	     *   1. convert DD specifications to CIEXYZ, then
+	     *   2. convert all in batches to the target DI format.
+	     *
+	     * Note that ConvertMixedColors will call WhiteAdjustProc
+	     * as necessary.
+	     */
+
+	    /*
+	     * Convert only DD specifications in batches of contiguous formats
+	     * to CIEXYZ
+	     *
+	     * Since DD->CIEXYZ, ConvertMixedColors will apply WhiteAdjustProc
+	     * if required.
+	     */
+	    retval = ConvertMixedColors(ccc, pColors_tmp, &clientWhitePt,
+		    nColors, XcmsCIEXYZFormat, (unsigned char)DD_FORMAT);
+
+	    /*
+	     * Because at this point we may have a mix of DI formats
+	     * (e.g., CIEXYZ, CIELuv) we must convert the specs to the
+	     * target DI format in batches of contiguous source formats.
+	     */
+	    retval = ConvertMixedColors(ccc, pColors_tmp, &clientWhitePt,
+		    nColors, targetFormat, (unsigned char)DI_FORMAT);
+	} else {
+	    /*
+	     * We need to convert from DI-to-DD and DD-to-DD, therefore
+	     *   1. convert DI specifications to CIEXYZ, then
+	     *   2. convert all to the DD target format.
+	     *
+	     *   This allows white point adjustment and gamut compression
+	     *	 to be applied to all the color specifications in one
+	     *   swoop if those functions do in fact modify the entire
+	     *   group of color specifications.
+	     */
+
+	    /*
+	     * Convert in batches to CIEXYZ
+	     *
+	     * If DD->CIEXYZ, ConvertMixedColors will apply WhiteAdjustProc
+	     * if required.
+	     */
+	    if ((retval = ConvertMixedColors(ccc, pColors_tmp, &clientWhitePt,
+		    nColors, XcmsCIEXYZFormat,
+		    (unsigned char)(DI_FORMAT | DD_FORMAT))) == XcmsFailure) {
+		goto Failure;
+	    }
+
+	    /*
+	     * Convert all specifications (now in CIEXYZ format) to
+	     * the target DD format.
+	     * Since CIEXYZ->DD, compression MAY take place therefore
+	     * we must pass pCompressed.
+	     * Note that WhiteAdjustProc must be used if necessary.
+	     */
+	    if (callWhiteAdjustProc) {
+		/*
+		 * White Point Adjustment
+		 *	Client White Point to Screen White Point
+		 */
+		retval = (*ccc->whitePtAdjProc)(ccc,
+			&clientWhitePt, ScreenWhitePointOfCCC(ccc),
+			targetFormat, pColors_tmp, nColors, pCompressed);
+	    } else {
+		retval = _XcmsDDConvertColors(ccc, pColors_tmp, nColors,
+			targetFormat, pCompressed);
+	    }
+	}
+    }
+
+    if (retval != XcmsFailure) {
+	memcpy((char *)pColors_in_out, (char *)pColors_tmp,
+	       nColors * sizeof(XcmsColor));
+    }
+    if (nColors > 1) {
+	Xfree((char *)pColors_tmp);
+    }
+    return(retval);
+
+Failure:
+    if (nColors > 1) {
+	Xfree((char *)pColors_tmp);
+    }
+    return(XcmsFailure);
+}
+
+
+/*
+ *	NAME
+ *		XcmsRegFormatOfPrefix
+ *
+ *	SYNOPSIS
+ */
+XcmsColorFormat
+_XcmsRegFormatOfPrefix(
+    _Xconst char *prefix)
+/*
+ *	DESCRIPTION
+ *		Returns a color space ID associated with the specified
+ *		X Consortium registered color space prefix.
+ *
+ *	RETURNS
+ *		The color space ID if found;
+ *		otherwise NULL.
+ */
+{
+    XcmsRegColorSpaceEntry *pEntry = _XcmsRegColorSpaces;
+
+    while (pEntry->prefix != NULL) {
+	if (strcmp(prefix, pEntry->prefix) == 0) {
+	    return(pEntry->id);
+	}
+	pEntry++;
+    }
+    return(XcmsUndefinedFormat);
+}
diff --git a/libtinyX11/GetColor.c b/libtinyX11/GetColor.c
index ed69f72..0917ad7 100644
--- a/libtinyX11/GetColor.c
+++ b/libtinyX11/GetColor.c
@@ -29,7 +29,8 @@ in this Software without prior written authorization from the X Consortium.
 #define NEED_REPLIES
 #include <stdio.h>
 #include "Xlibint.h"
-//#include "Xcmsint.h"
+#include "Xcmsint.h"
+#include <X11/Xcms.h>
 
 extern void _XcmsRGB_to_XColor();
 
diff --git a/libtinyX11/HVC.c b/libtinyX11/HVC.c
new file mode 100644
index 0000000..80f1735
--- /dev/null
+++ b/libtinyX11/HVC.c
@@ -0,0 +1,625 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  TekColor is a
+ * trademark of Tektronix, Inc.  The term "TekHVC" designates a particular
+ * color space that is the subject of U.S. Patent No. 4,985,853 (equivalent
+ * foreign patents pending).  Permission is hereby granted to use, copy,
+ * modify, sell, and otherwise distribute this software and its
+ * documentation for any purpose and without fee, provided that:
+ *
+ * 1. This copyright, permission, and disclaimer notice is reproduced in
+ *    all copies of this software and any modification thereof and in
+ *    supporting documentation;
+ * 2. Any color-handling application which displays TekHVC color
+ *    cooordinates identifies these as TekHVC color coordinates in any
+ *    interface that displays these coordinates and in any associated
+ *    documentation;
+ * 3. The term "TekHVC" is always used, and is only used, in association
+ *    with the mathematical derivations of the TekHVC Color Space,
+ *    including those provided in this file and any equivalent pathways and
+ *    mathematical derivations, regardless of digital (e.g., floating point
+ *    or integer) representation.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		TekHVC.c
+ *
+ *	DESCRIPTION
+ *		This file contains routines that support the TekHVC
+ *		color space to include conversions to and from the CIE
+ *		XYZ space.
+ *
+ *	DOCUMENTATION
+ *		"TekColor Color Management System, System Implementor's Manual"
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include <X11/Xos.h>
+#include <math.h>
+#include "Cv.h"
+
+#include <stdio.h>
+
+/*
+ *	DEFINES
+ */
+#define u_BR    0.7127          /* u' Best Red */
+#define v_BR    0.4931          /* v' Best Red */
+#define EPS     0.001
+#define CHROMA_SCALE_FACTOR   7.50725
+#ifndef PI
+#  ifdef M_PI
+#    define PI	M_PI
+#  else
+#    define PI       3.14159265358979323846264338327950
+#  endif
+#endif
+#ifndef degrees
+#  define degrees(r) ((XcmsFloat)(r) * 180.0 / PI)
+#endif /* degrees */
+#ifndef radians
+#  define radians(d) ((XcmsFloat)(d) * PI / 180.0)
+#endif /* radians */
+
+/*************************************************************************
+ * Note: The DBL_EPSILON for ANSI is 1e-5 so my checks need to take
+ *       this into account.  If your DBL_EPSILON is different then
+ *       adjust this define.
+ *
+ *       Also note that EPS is the error factor in the calculations
+ *       This may need to be the same as XMY_DBL_EPSILON in
+ *       some implementations.
+ **************************************************************************/
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+
+/*
+ *	FORWARD DECLARATIONS
+ */
+static int TekHVC_ParseString(register char *spec, XcmsColor *pColor);
+static Status XcmsTekHVC_ValidSpec(XcmsColor *pColor);
+
+/*
+ *	LOCAL VARIABLES
+ */
+
+    /*
+     * NULL terminated list of functions applied to get from TekHVC to CIEXYZ
+     */
+static XcmsConversionProc Fl_TekHVC_to_CIEXYZ[] = {
+    XcmsTekHVCToCIEuvY,
+    XcmsCIEuvYToCIEXYZ,
+    NULL
+};
+
+    /*
+     * NULL terminated list of functions applied to get from CIEXYZ to TekHVC
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_TekHVC[] = {
+    XcmsCIEXYZToCIEuvY,
+    XcmsCIEuvYToTekHVC,
+    NULL
+};
+
+/*
+ *	GLOBALS
+ */
+
+    /*
+     * TekHVC Color Space
+     */
+XcmsColorSpace	XcmsTekHVCColorSpace =
+    {
+	_XcmsTekHVC_prefix,	/* prefix */
+	XcmsTekHVCFormat,		/* id */
+	TekHVC_ParseString,	/* parseString */
+	Fl_TekHVC_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_TekHVC,	/* from_CIEXYZ */
+	1
+    };
+
+
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		TekHVC_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+TekHVC_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsTekHVCFormat.
+ *		The assumed TekHVC string syntax is:
+ *		    TekHVC:<H>/<V>/<C>
+ *		Where H, V, and C are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid;
+ *		XcmsSuccess if valid.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsTekHVC_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.TekHVC.H,
+	    &pColor->spec.TekHVC.V,
+	    &pColor->spec.TekHVC.C) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.TekHVC.H,
+		       &pColor->spec.TekHVC.V,
+		       &pColor->spec.TekHVC.C) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	    return(XcmsFailure);
+    }
+    pColor->format = XcmsTekHVCFormat;
+    pColor->pixel = 0;
+    return(XcmsTekHVC_ValidSpec(pColor));
+}
+
+
+/*
+ *	NAME
+ *		ThetaOffset -- compute thetaOffset
+ *
+ *	SYNOPSIS
+ */
+static int
+ThetaOffset(
+    XcmsColor *pWhitePt,
+    XcmsFloat *pThetaOffset)
+/*
+ *	DESCRIPTION
+ *		This routine computes the theta offset of a given
+ *		white point, i.e. XcmsColor.  It is used in both this
+ *		conversion and the printer conversions.
+ *
+ *	RETURNS
+ *		0 if failed.
+ *		1 if succeeded with no modifications.
+ *
+ *	ASSUMPTIONS
+ *		Assumes:
+ *			pWhitePt != NULL
+ *			pWhitePt->format == XcmsCIEuvYFormat
+ *
+ */
+{
+    double div, slopeuv;
+
+    if (pWhitePt == NULL || pWhitePt->format != XcmsCIEuvYFormat) {
+	return(0);
+    }
+
+    if ((div = u_BR - pWhitePt->spec.CIEuvY.u_prime) == 0.0) {
+	return(0);
+    }
+    slopeuv = (v_BR - pWhitePt->spec.CIEuvY.v_prime) / div;
+    *pThetaOffset = degrees(XCMS_ATAN(slopeuv));
+    return(1);
+}
+
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsTekHVC_ValidSpec()
+ *
+ *	SYNOPSIS
+ */
+static int
+XcmsTekHVC_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if values in the color specification are valid.
+ *		Also brings hue into the range 0.0 <= Hue < 360.0
+ *
+ *	RETURNS
+ *		0 if not valid.
+ *		1 if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsTekHVCFormat) {
+	return(XcmsFailure);
+    }
+    if (pColor->spec.TekHVC.V < (0.0 - XMY_DBL_EPSILON)
+	    || pColor->spec.TekHVC.V > (100.0 + XMY_DBL_EPSILON)
+	    || (pColor->spec.TekHVC.C < 0.0 - XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+
+    if (pColor->spec.TekHVC.V < 0.0) {
+	    pColor->spec.TekHVC.V = 0.0 + XMY_DBL_EPSILON;
+    } else if (pColor->spec.TekHVC.V > 100.0) {
+	pColor->spec.TekHVC.V = 100.0 - XMY_DBL_EPSILON;
+    }
+
+    if (pColor->spec.TekHVC.C < 0.0) {
+	pColor->spec.TekHVC.C = 0.0 - XMY_DBL_EPSILON;
+    }
+
+    while (pColor->spec.TekHVC.H < 0.0) {
+	pColor->spec.TekHVC.H += 360.0;
+    }
+    while (pColor->spec.TekHVC.H >= 360.0) {
+	pColor->spec.TekHVC.H -= 360.0;
+    }
+    return(XcmsSuccess);
+}
+
+/*
+ *	NAME
+ *		XcmsTekHVCToCIEuvY - convert TekHVC to CIEuvY
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsTekHVCToCIEuvY(
+    XcmsCCC ccc,
+    XcmsColor *pHVC_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Transforms an array of TekHVC color specifications, given
+ *		their associated white point, to CIECIEuvY.color
+ *		specifications.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed, XcmsSuccess otherwise.
+ *
+ */
+{
+    XcmsFloat	thetaOffset;
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsColor	whitePt;
+    XcmsCIEuvY	uvY_return;
+    XcmsFloat	tempHue, u, v;
+    XcmsFloat	tmpVal;
+    register int i;
+
+    /*
+     * Check arguments
+     */
+    if (pHVC_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEuvY form
+     */
+    if (pHVC_WhitePt->format != XcmsCIEuvYFormat) {
+	/* Make copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pHVC_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL, 1,
+		XcmsCIEuvYFormat)) {
+	    return(XcmsFailure);
+	}
+	pHVC_WhitePt = &whitePt;
+    }
+    /* Make sure it is a white point, i.e., Y == 1.0 */
+    if (pHVC_WhitePt->spec.CIEuvY.Y != 1.0) {
+	return(XcmsFailure);
+    }
+
+    /* Get the thetaOffset */
+    if (!ThetaOffset(pHVC_WhitePt, &thetaOffset)) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is TekHVC and is valid */
+	if (!XcmsTekHVC_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	if (pColor->spec.TekHVC.V == 0.0 || pColor->spec.TekHVC.V == 100.0) {
+	    if (pColor->spec.TekHVC.V == 100.0) {
+		uvY_return.Y = 1.0;
+	    } else { /* pColor->spec.TekHVC.V == 0.0 */
+		uvY_return.Y = 0.0;
+	    }
+	    uvY_return.u_prime = pHVC_WhitePt->spec.CIEuvY.u_prime;
+	    uvY_return.v_prime = pHVC_WhitePt->spec.CIEuvY.v_prime;
+	} else {
+
+	    /* Find the hue based on the white point offset */
+	    tempHue = pColor->spec.TekHVC.H + thetaOffset;
+
+	    while (tempHue < 0.0) {
+		tempHue += 360.0;
+	    }
+	    while (tempHue >= 360.0) {
+		tempHue -= 360.0;
+	    }
+
+	    tempHue = radians(tempHue);
+
+	    /* Calculate u'v' for the obtained hue */
+	    u = (XcmsFloat) ((XCMS_COS(tempHue) * pColor->spec.TekHVC.C) /
+		    (pColor->spec.TekHVC.V * (double)CHROMA_SCALE_FACTOR));
+	    v = (XcmsFloat) ((XCMS_SIN(tempHue) * pColor->spec.TekHVC.C) /
+		    (pColor->spec.TekHVC.V * (double)CHROMA_SCALE_FACTOR));
+
+	    /* Based on the white point get the offset from best red */
+	    uvY_return.u_prime = u + pHVC_WhitePt->spec.CIEuvY.u_prime;
+	    uvY_return.v_prime = v + pHVC_WhitePt->spec.CIEuvY.v_prime;
+
+	    /* Calculate the Y value based on the L* = V. */
+	    if (pColor->spec.TekHVC.V < 7.99953624) {
+		uvY_return.Y = pColor->spec.TekHVC.V / 903.29;
+	    } else {
+		tmpVal = (pColor->spec.TekHVC.V + 16.0) / 116.0;
+		uvY_return.Y = tmpVal * tmpVal * tmpVal; /* tmpVal ** 3 */
+	    }
+	}
+
+	/* Copy result to pColor */
+	memcpy((char *)&pColor->spec, (char *)&uvY_return, sizeof(XcmsCIEuvY));
+
+	/* Identify that the format is now CIEuvY */
+	pColor->format = XcmsCIEuvYFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEuvYToTekHVC - convert CIEuvY to TekHVC
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIEuvYToTekHVC(
+    XcmsCCC ccc,
+    XcmsColor *pHVC_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Transforms an array of CIECIEuvY.color specifications, given
+ *		their assiciated white point, to TekHVC specifications.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed, XcmsSuccess otherwise.
+ *
+ */
+{
+    XcmsFloat	theta, L2, u, v, nThetaLow, nThetaHigh;
+    XcmsFloat	thetaOffset;
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsColor	whitePt;
+    XcmsTekHVC	HVC_return;
+    register int i;
+
+    /*
+     * Check arguments
+     */
+    if (pHVC_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEuvY form
+     */
+    if (pHVC_WhitePt->format != XcmsCIEuvYFormat) {
+	/* Make copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pHVC_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL, 1,
+		XcmsCIEuvYFormat)) {
+	    return(XcmsFailure);
+	}
+	pHVC_WhitePt = &whitePt;
+    }
+    /* Make sure it is a white point, i.e., Y == 1.0 */
+    if (pHVC_WhitePt->spec.CIEuvY.Y != 1.0) {
+	return(XcmsFailure);
+    }
+    if (!ThetaOffset(pHVC_WhitePt, &thetaOffset)) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+	if (!_XcmsCIEuvY_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/* Use the white point offset to determine HVC */
+	u = pColor->spec.CIEuvY.u_prime - pHVC_WhitePt->spec.CIEuvY.u_prime;
+	v = pColor->spec.CIEuvY.v_prime - pHVC_WhitePt->spec.CIEuvY.v_prime;
+
+	/* Calculate the offset */
+	if (u == 0.0) {
+	    theta = 0.0;
+	} else {
+	    theta = v / u;
+	    theta = (XcmsFloat) XCMS_ATAN((double)theta);
+	    theta = degrees(theta);
+	}
+
+	nThetaLow = 0.0;
+	nThetaHigh = 360.0;
+	if (u > 0.0 && v > 0.0) {
+	    nThetaLow = 0.0;
+	    nThetaHigh = 90.0;
+	} else if (u < 0.0 && v > 0.0) {
+	    nThetaLow = 90.0;
+	    nThetaHigh = 180.0;
+	} else if (u < 0.0 && v < 0.0) {
+	    nThetaLow = 180.0;
+	    nThetaHigh = 270.0;
+	} else if (u > 0.0 && v < 0.0) {
+	    nThetaLow = 270.0;
+	    nThetaHigh = 360.0;
+	}
+	while (theta < nThetaLow) {
+		theta += 90.0;
+	}
+	while (theta >= nThetaHigh) {
+	    theta -= 90.0;
+	}
+
+	/* calculate the L value from the given Y */
+	L2 = (pColor->spec.CIEuvY.Y < 0.008856)
+	    ?
+	    (pColor->spec.CIEuvY.Y * 903.29)
+	    :
+	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
+	HVC_return.C = L2 * CHROMA_SCALE_FACTOR * XCMS_SQRT((double) ((u * u) + (v * v)));
+	if (HVC_return.C < 0.0) {
+	    theta = 0.0;
+	}
+	HVC_return.V = L2;
+	HVC_return.H = theta - thetaOffset;
+
+	/*
+	 * If this is within the error margin let some other routine later
+	 * in the chain worry about the slop in the calculations.
+	 */
+	while (HVC_return.H < -EPS) {
+	    HVC_return.H += 360.0;
+	}
+	while (HVC_return.H >= 360.0 + EPS) {
+	    HVC_return.H -= 360.0;
+	}
+
+	/* Copy result to pColor */
+	memcpy((char *)&pColor->spec, (char *)&HVC_return, sizeof(XcmsTekHVC));
+
+	/* Identify that the format is now CIEuvY */
+	pColor->format = XcmsTekHVCFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsTekHVC_CheckModify
+ *
+ *	SYNOPSIS
+ */
+int
+_XcmsTekHVC_CheckModify(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if values in the color specification are valid.
+ *		If they are not it modifies the values.
+ *		Also brings hue into the range 0.0 <= Hue < 360.0
+ *
+ *	RETURNS
+ *		0 if not valid.
+ *		1 if valid.
+ *
+ */
+{
+    int n;
+
+    /* For now only use the TekHVC numbers as inputs */
+    if (pColor->format != XcmsTekHVCFormat) {
+	return(0);
+    }
+
+    if (pColor->spec.TekHVC.V < 0.0) {
+	pColor->spec.TekHVC.V = 0.0 + XMY_DBL_EPSILON;
+    } else if (pColor->spec.TekHVC.V > 100.0) {
+	pColor->spec.TekHVC.V = 100.0 - XMY_DBL_EPSILON;
+    }
+
+    if (pColor->spec.TekHVC.C < 0.0) {
+	pColor->spec.TekHVC.C = 0.0 - XMY_DBL_EPSILON;
+    }
+
+    if (pColor->spec.TekHVC.H < 0.0) {
+	n = -pColor->spec.TekHVC.H / 360.0;
+	pColor->spec.TekHVC.H += (n + 1) * 360.0;
+	if (pColor->spec.TekHVC.H >= 360.0)
+	    pColor->spec.TekHVC.H -= 360.0;
+    } else if (pColor->spec.TekHVC.H >= 360.0) {
+	n = pColor->spec.TekHVC.H / 360.0;
+	pColor->spec.TekHVC.H -= n * 360.0;
+    }
+    return(1);
+}
diff --git a/libtinyX11/HVCGcC.c b/libtinyX11/HVCGcC.c
new file mode 100644
index 0000000..6d52eac
--- /dev/null
+++ b/libtinyX11/HVCGcC.c
@@ -0,0 +1,149 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  TekColor is a
+ * trademark of Tektronix, Inc.  The term "TekHVC" designates a particular
+ * color space that is the subject of U.S. Patent No. 4,985,853 (equivalent
+ * foreign patents pending).  Permission is hereby granted to use, copy,
+ * modify, sell, and otherwise distribute this software and its
+ * documentation for any purpose and without fee, provided that:
+ *
+ * 1. This copyright, permission, and disclaimer notice is reproduced in
+ *    all copies of this software and any modification thereof and in
+ *    supporting documentation;
+ * 2. Any color-handling application which displays TekHVC color
+ *    cooordinates identifies these as TekHVC color coordinates in any
+ *    interface that displays these coordinates and in any associated
+ *    documentation;
+ * 3. The term "TekHVC" is always used, and is only used, in association
+ *    with the mathematical derivations of the TekHVC Color Space,
+ *    including those provided in this file and any equivalent pathways and
+ *    mathematical derivations, regardless of digital (e.g., floating point
+ *    or integer) representation.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		TekHVCGcC.c
+ *
+ *	DESCRIPTION
+ *		Source for XcmsTekHVCClipC() gamut compression routine.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsTekHVCClipC - Reduce the chroma for a hue and value
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsTekHVCClipC (
+    XcmsCCC ccc,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors,
+    unsigned int i,
+    Bool *pCompressed)
+/*
+ *	DESCRIPTION
+ *		Reduce the Chroma for a specific hue and value to
+ *		to bring the given color into the gamut of the
+ *		specified device.  As required of gamut compression
+ *		functions in Xcms, this routine returns pColor_in_out
+ *		in XcmsCIEXYZFormat on successful completion.
+ *
+ *		Since this routine works with the value within
+ *		pColor_in_out intermediate results may be returned
+ *		even though it may be invalid.
+ *
+ *	RETURNS
+ *		XcmsFailure - Failure
+ *              XcmsSuccess - Succeeded
+ *
+ */
+{
+    Status retval;
+    XcmsColor *pColor;
+
+    /*
+     * Color specification passed as input can be assumed to:
+     *	1. Be in XcmsCIEXYZFormat
+     *	2. Already be white point adjusted for the Screen White Point.
+     *	    This means that the white point now associated with this
+     *	    color spec is the Screen White Point (even if the
+     *	    ccc->clientWhitePt differs).
+     */
+
+    /*
+     * Insure TekHVC installed
+     */
+    if (XcmsAddColorSpace(&XcmsTekHVCColorSpace) == XcmsFailure) {
+	return(XcmsFailure);
+    }
+
+    pColor = pColors_in_out + i;
+
+    if (ccc->visual->class < StaticColor &&
+	    FunctionSetOfCCC(ccc) != (XPointer) &XcmsLinearRGBFunctionSet) {
+	/*
+	 * GRAY !
+	 */
+	_XcmsDIConvertColors(ccc, pColor, &ccc->pPerScrnInfo->screenWhitePt,
+		1, XcmsTekHVCFormat);
+	pColor->spec.TekHVC.H = pColor->spec.TekHVC.C = 0.0;
+	_XcmsDIConvertColors(ccc, pColor, &ccc->pPerScrnInfo->screenWhitePt,
+		1, XcmsCIEXYZFormat);
+	if (pCompressed) {
+	    *(pCompressed + i) = True;
+	}
+	return(XcmsSuccess);
+    } else {
+	if (pColor->format != XcmsTekHVCFormat) {
+	    if (_XcmsDIConvertColors(ccc, pColor,
+		    &ccc->pPerScrnInfo->screenWhitePt, 1, XcmsTekHVCFormat)
+		    == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+	}
+	if (XcmsTekHVCQueryMaxC(ccc,
+		pColor->spec.TekHVC.H,
+		pColor->spec.TekHVC.V,
+		pColor)
+		== XcmsFailure) {
+	    return(XcmsFailure);
+	}
+	retval = _XcmsDIConvertColors(ccc, pColor,
+		&ccc->pPerScrnInfo->screenWhitePt, 1, XcmsCIEXYZFormat);
+	if (retval != XcmsFailure && pCompressed != NULL) {
+	    *(pCompressed + i) = True;
+	}
+	return(retval);
+    }
+}
diff --git a/libtinyX11/HVCMxC.c b/libtinyX11/HVCMxC.c
new file mode 100644
index 0000000..074844c
--- /dev/null
+++ b/libtinyX11/HVCMxC.c
@@ -0,0 +1,243 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  TekColor is a
+ * trademark of Tektronix, Inc.  The term "TekHVC" designates a particular
+ * color space that is the subject of U.S. Patent No. 4,985,853 (equivalent
+ * foreign patents pending).  Permission is hereby granted to use, copy,
+ * modify, sell, and otherwise distribute this software and its
+ * documentation for any purpose and without fee, provided that:
+ *
+ * 1. This copyright, permission, and disclaimer notice is reproduced in
+ *    all copies of this software and any modification thereof and in
+ *    supporting documentation;
+ * 2. Any color-handling application which displays TekHVC color
+ *    cooordinates identifies these as TekHVC color coordinates in any
+ *    interface that displays these coordinates and in any associated
+ *    documentation;
+ * 3. The term "TekHVC" is always used, and is only used, in association
+ *    with the mathematical derivations of the TekHVC Color Space,
+ *    including those provided in this file and any equivalent pathways and
+ *    mathematical derivations, regardless of digital (e.g., floating point
+ *    or integer) representation.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		TekHVCMxC.c
+ *
+ *	DESCRIPTION
+ *		Source for the XcmsTekHVCQueryMaxC() gamut boudary
+ *		querying routine.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include <math.h>
+#include "Cv.h"
+
+/*
+ *	DEFINES
+ */
+#define MAXBISECTCOUNT	100
+#define EPS	        0.001
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsTekHVCQueryMaxC - Compute the maximum chroma for a hue and value
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsTekHVCQueryMaxC(
+    XcmsCCC ccc,
+    XcmsFloat hue,
+    XcmsFloat value,
+    XcmsColor *pColor_return)
+/*
+ *	DESCRIPTION
+ *		Return the maximum chroma for a specific hue and value.
+ *		The returned format is in XcmsTekHVCFormat.
+ *
+ *
+ *	ASSUMPTIONS
+ *		This routine assumes that the white point associated with
+ *		the color specification is the Screen White Point.  The
+ *		Screen White Point will also be associated with the
+ *		returned color specification.
+ *
+ *	RETURNS
+ *		XcmsFailure - Failure
+ *              XcmsSuccess - Succeeded
+ *
+ */
+{
+    XcmsCCCRec	myCCC;
+    XcmsColor  tmp;
+    XcmsColor  max_vc;
+    XcmsRGBi   rgb_saved;
+    int nCount, nMaxCount;
+    XcmsFloat nValue, savedValue, lastValue, lastChroma, prevValue;
+    XcmsFloat maxDist, nT, rFactor;
+    XcmsFloat ftmp1, ftmp2;
+
+    /*
+     * Check Arguments
+     */
+    if (ccc == NULL || pColor_return == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Insure TekHVC installed
+     */
+    if (XcmsAddColorSpace(&XcmsTekHVCColorSpace) == XcmsFailure) {
+	return(XcmsFailure);
+    }
+
+    /* Use my own CCC */
+    memcpy ((char *)&myCCC, (char *)ccc, sizeof(XcmsCCCRec));
+    myCCC.clientWhitePt.format = XcmsUndefinedFormat; /* inherit screen white Pt */
+    myCCC.gamutCompProc = (XcmsCompressionProc)NULL;/* no gamut comp func */
+
+    tmp.spec.TekHVC.H = hue;
+    tmp.spec.TekHVC.V = value;
+    tmp.spec.TekHVC.C = 100.0;
+    tmp.pixel = pColor_return->pixel;
+    tmp.format = XcmsTekHVCFormat;
+
+    /* check to make sure we have a valid TekHVC number */
+    if (!_XcmsTekHVC_CheckModify(&tmp)) {
+	return(XcmsFailure);
+    }
+
+    /* Step 1: compute the maximum value and chroma for this hue. */
+    memcpy((char *)&max_vc, (char *)&tmp, sizeof(XcmsColor));
+    if (_XcmsTekHVCQueryMaxVCRGB(&myCCC, hue, &max_vc, &rgb_saved)
+	    == XcmsFailure) {
+	return(XcmsFailure);
+    }
+
+    /* Step 2: If the value is less than the value for the maximum */
+    /*         value, chroma point then the chroma is on the line  */
+    /*         from max_vc to 0,0. */
+    if (value <= max_vc.spec.TekHVC.V) {
+	tmp.spec.TekHVC.C = value
+			      * max_vc.spec.TekHVC.C / max_vc.spec.TekHVC.V;
+	if (_XcmsTekHVC_CheckModify (&tmp)) {
+	    memcpy((char *)pColor_return, (char *)&tmp, sizeof(XcmsColor));
+	    return(XcmsSuccess);
+	} else {
+	    return(XcmsFailure);
+	}
+    } else {
+	/* must do a bisection here to compute the maximum chroma */
+	/* save the structure input so that any elements that */
+	/* are not touched are recopied later in the routine. */
+	nValue = savedValue = value;
+	lastChroma = -1.0;
+	lastValue = -1.0;
+	nMaxCount = MAXBISECTCOUNT;
+	maxDist = 100.0 - max_vc.spec.TekHVC.V;
+	rFactor = 1.0;
+
+	for (nCount = 0; nCount < nMaxCount; nCount++) {
+	    prevValue =  lastValue;
+	    lastValue =  tmp.spec.TekHVC.V;
+	    lastChroma = tmp.spec.TekHVC.C;
+	    nT = (nValue - max_vc.spec.TekHVC.V) / maxDist * rFactor;
+	    tmp.spec.RGBi.red = rgb_saved.red * (1.0 - nT) + nT;
+	    tmp.spec.RGBi.green = rgb_saved.green * (1.0 - nT) + nT;
+	    tmp.spec.RGBi.blue  = rgb_saved.blue * (1.0 - nT) + nT;
+	    tmp.format = XcmsRGBiFormat;
+
+	    /* convert from RGB to HVC */
+	    if (_XcmsConvertColorsWithWhitePt(&myCCC, &tmp,
+		    &myCCC.pPerScrnInfo->screenWhitePt, 1, XcmsTekHVCFormat,
+		    (Bool *) NULL) == XcmsFailure) {
+		return(XcmsFailure);
+	    }
+
+	    /* Now check the return against what is expected */
+	    if (tmp.spec.TekHVC.V <= savedValue + EPS &&
+		tmp.spec.TekHVC.V >= savedValue - EPS) {
+		/* make sure to return the input hue */
+		tmp.spec.TekHVC.H = hue;
+		if (_XcmsTekHVC_CheckModify (&tmp)) {
+		    memcpy((char *)pColor_return, (char *)&tmp, sizeof(XcmsColor));
+		    return(XcmsSuccess);
+		} else {
+		    return(XcmsFailure);
+		}
+	    }
+	    nValue += savedValue - tmp.spec.TekHVC.V;
+	    if (nValue < max_vc.spec.TekHVC.V) {
+		nValue = max_vc.spec.TekHVC.V;
+		rFactor *= 0.5;  /* selective relaxation employed */
+	    } else if (nValue > 100.0) {
+		/* make sure to return the input hue */
+		tmp.spec.TekHVC.H = hue;
+		/* avoid using fabs */
+		ftmp1 = lastValue - savedValue;
+		if (ftmp1 < 0.0)
+		    ftmp1 = -ftmp1;
+		ftmp2 = tmp.spec.TekHVC.V - savedValue;
+		if (ftmp2 < 0.0)
+		    ftmp2 = -ftmp2;
+		if (ftmp1 < ftmp2) {
+		    tmp.spec.TekHVC.V = lastValue;
+		    tmp.spec.TekHVC.C = lastChroma;
+		}
+		if (_XcmsTekHVC_CheckModify (&tmp)) {
+		    memcpy((char *)pColor_return, (char *)&tmp, sizeof(XcmsColor));
+		    return(XcmsSuccess);
+		} else {
+		    return(XcmsFailure);
+		}
+	    } else if (tmp.spec.TekHVC.V <= prevValue + EPS &&
+		       tmp.spec.TekHVC.V >= prevValue - EPS) {
+		rFactor *= 0.5;  /* selective relaxation employed */
+	    }
+	}
+	if (nCount >= nMaxCount) {
+	    /* avoid using fabs */
+	    ftmp1 = lastValue - savedValue;
+	    if (ftmp1 < 0.0)
+		ftmp1 = -ftmp1;
+	    ftmp2 = tmp.spec.TekHVC.V - savedValue;
+	    if (ftmp2 < 0.0)
+		ftmp2 = -ftmp2;
+	    if (ftmp1 < ftmp2) {
+		tmp.spec.TekHVC.V = lastValue;
+		tmp.spec.TekHVC.C = lastChroma;
+	    }
+	}
+    }
+    /* make sure to return the input hue */
+    tmp.spec.TekHVC.H = hue;
+    memcpy((char *)pColor_return, (char *)&tmp, sizeof(XcmsColor));
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/HVCMxVC.c b/libtinyX11/HVCMxVC.c
new file mode 100644
index 0000000..c7e0878
--- /dev/null
+++ b/libtinyX11/HVCMxVC.c
@@ -0,0 +1,235 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  TekColor is a
+ * trademark of Tektronix, Inc.  The term "TekHVC" designates a particular
+ * color space that is the subject of U.S. Patent No. 4,985,853 (equivalent
+ * foreign patents pending).  Permission is hereby granted to use, copy,
+ * modify, sell, and otherwise distribute this software and its
+ * documentation for any purpose and without fee, provided that:
+ *
+ * 1. This copyright, permission, and disclaimer notice is reproduced in
+ *    all copies of this software and any modification thereof and in
+ *    supporting documentation;
+ * 2. Any color-handling application which displays TekHVC color
+ *    cooordinates identifies these as TekHVC color coordinates in any
+ *    interface that displays these coordinates and in any associated
+ *    documentation;
+ * 3. The term "TekHVC" is always used, and is only used, in association
+ *    with the mathematical derivations of the TekHVC Color Space,
+ *    including those provided in this file and any equivalent pathways and
+ *    mathematical derivations, regardless of digital (e.g., floating point
+ *    or integer) representation.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		TekHVCMxVC.c
+ *
+ *	DESCRIPTION
+ *		Source for the XcmsTekHVCQueryMaxVC() gamut boundary
+ *		querying routine.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *	DEFINES
+ */
+#define MIN(x,y) ((x) > (y) ? (y) : (x))
+#define MIN3(x,y,z) ((x) > (MIN((y), (z))) ? (MIN((y), (z))) : (x))
+#define MAX(x,y) ((x) > (y) ? (x) : (y))
+#define MAX3(x,y,z) ((x) > (MAX((y), (z))) ? (x) : (MAX((y), (z))))
+#define START_V	    40.0
+#define START_C	    120.0
+
+
+/************************************************************************
+ *									*
+ *			 API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsTekHVCQueryMaxVCRGB - Compute maximum value/chroma.
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsTekHVCQueryMaxVCRGB(
+    XcmsCCC	ccc,
+    XcmsFloat	hue,
+    XcmsColor   *pColor_return,
+    XcmsRGBi    *pRGB_return)
+
+/*
+ *	DESCRIPTION
+ *		Return the maximum chroma for a specified hue, and the
+ *		corresponding value.  This is computed by a binary search of
+ *		all possible chromas.  An assumption is made that there are
+ *		no local maxima.  Use the unrounded Max Chroma because
+ *		the difference check can be small.
+ *
+ *		NOTE:  No local CCC is used because this is a private
+ *		       routine and all routines that call it are expected
+ *		       to behave properly, i.e. send a local CCC with
+ *		       no white adjust function and no gamut compression
+ *		       function.
+ *
+ *		This routine only accepts hue as input and outputs
+ *		HVC's and RGBi's.
+ *
+ *	RETURNS
+ *		XcmsFailure - Failure
+ *		XCMS_SUCCUSS - Succeeded
+ *
+ */
+{
+    XcmsFloat nSmall, nLarge;
+    XcmsColor tmp;
+
+    tmp.format = XcmsTekHVCFormat;
+    tmp.spec.TekHVC.H = hue;
+    /*  Use some unreachable color on the given hue */
+    tmp.spec.TekHVC.V = START_V;
+    tmp.spec.TekHVC.C = START_C;
+
+
+    /*
+     * Convert from HVC to RGB
+     *
+     * Note that the CIEXYZ to RGBi conversion routine must stuff the
+     * out of bounds RGBi values in tmp when the ccc->gamutCompProc
+     * is NULL.
+     */
+    if ((_XcmsConvertColorsWithWhitePt(ccc, &tmp,
+	    &ccc->pPerScrnInfo->screenWhitePt, 1, XcmsRGBiFormat, (Bool *) NULL)
+	    == XcmsFailure) && tmp.format != XcmsRGBiFormat) {
+	return (XcmsFailure);
+    }
+
+    /* Now pick the smallest RGB */
+    nSmall = MIN3(tmp.spec.RGBi.red,
+		  tmp.spec.RGBi.green,
+		  tmp.spec.RGBi.blue);
+    /* Make the smallest RGB equal to zero */
+    tmp.spec.RGBi.red   -= nSmall;
+    tmp.spec.RGBi.green -= nSmall;
+    tmp.spec.RGBi.blue  -= nSmall;
+
+    /* Now pick the largest RGB */
+    nLarge = MAX3(tmp.spec.RGBi.red,
+		  tmp.spec.RGBi.green,
+		  tmp.spec.RGBi.blue);
+    /* Scale the RGB values based on the largest one */
+    tmp.spec.RGBi.red   /= nLarge;
+    tmp.spec.RGBi.green /= nLarge;
+    tmp.spec.RGBi.blue  /= nLarge;
+    tmp.format = XcmsRGBiFormat;
+
+    /* If the calling routine wants RGB value give them the ones used. */
+    if (pRGB_return) {
+	pRGB_return->red   = tmp.spec.RGBi.red;
+	pRGB_return->green = tmp.spec.RGBi.green;
+	pRGB_return->blue  = tmp.spec.RGBi.blue;
+    }
+
+    /* Convert from RGBi to HVC */
+    if (_XcmsConvertColorsWithWhitePt(ccc, &tmp,
+	    &ccc->pPerScrnInfo->screenWhitePt, 1, XcmsTekHVCFormat, (Bool *) NULL)
+	    == XcmsFailure) {
+	return (XcmsFailure);
+    }
+
+    /* make sure to return the input hue */
+    tmp.spec.TekHVC.H = hue;
+    memcpy((char *)pColor_return, (char *)&tmp, sizeof(XcmsColor));
+    return (XcmsSuccess);
+}
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsTekHVCQueryMaxVC - Compute maximum value and chroma.
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsTekHVCQueryMaxVC (
+    XcmsCCC ccc,
+    XcmsFloat hue,
+    XcmsColor *pColor_return)
+
+/*
+ *	DESCRIPTION
+ *		Return the maximum chroma for the specified hue, and the
+ *		corresponding value.
+ *
+ *	ASSUMPTIONS
+ *		This routine assumes that the white point associated with
+ *		the color specification is the Screen White Point.  The
+ *		Screen White Point will also be associated with the
+ *		returned color specification.
+ *
+ *	RETURNS
+ *		XcmsFailure - Failure
+ *		XcmsSuccess - Succeeded
+ *
+ */
+{
+    XcmsCCCRec myCCC;
+
+    /*
+     * Check Arguments
+     */
+    if (ccc == NULL || pColor_return == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Insure TekHVC installed
+     */
+    if (XcmsAddColorSpace(&XcmsTekHVCColorSpace) == XcmsFailure) {
+	return(XcmsFailure);
+    }
+
+    /* Use my own CCC */
+    memcpy ((char *)&myCCC, (char *)ccc, sizeof(XcmsCCCRec));
+    myCCC.clientWhitePt.format = XcmsUndefinedFormat;
+    myCCC.gamutCompProc = (XcmsCompressionProc)NULL;
+
+    while (hue < 0.0) {
+	hue += 360.0;
+    }
+    while (hue >= 360.0) {
+	hue -= 360.0;
+    }
+
+    return(_XcmsTekHVCQueryMaxVCRGB (&myCCC, hue, pColor_return,
+	    (XcmsRGBi *)NULL));
+}
diff --git a/libtinyX11/LRGB.c b/libtinyX11/LRGB.c
new file mode 100644
index 0000000..4e9f029
--- /dev/null
+++ b/libtinyX11/LRGB.c
@@ -0,0 +1,1847 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsLRGB.c
+ *
+ *	DESCRIPTION
+ *		This file contains the conversion routines:
+ *		    1. CIE XYZ to RGB intensity
+ *		    2. RGB intensity to device RGB
+ *		    3. device RGB to RGB intensity
+ *		    4. RGB intensity to CIE XYZ
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdio.h>
+#include <X11/Xos.h>
+#include <X11/Xatom.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *      LOCAL DEFINES
+ *		#define declarations local to this package.
+ */
+#define EPS	0.001
+#ifndef MIN
+#define MIN(x,y) ((x) > (y) ? (y) : (x))
+#endif /* MIN */
+#ifndef MAX
+#define MAX(x,y) ((x) > (y) ? (x) : (y))
+#endif /* MAX */
+#ifndef MIN3
+#define MIN3(x,y,z) ((x) > (MIN((y), (z))) ? (MIN((y), (z))) : (x))
+#endif /* MIN3 */
+#ifndef MAX3
+#define MAX3(x,y,z) ((x) > (MAX((y), (z))) ? (x) : (MAX((y), (z))))
+#endif /* MAX3 */
+
+/*
+ *      LOCAL TYPEDEFS
+ *              typedefs local to this package (for use with local vars).
+ *
+ */
+
+/*
+ *      FORWARD DECLARATIONS
+ */
+static void LINEAR_RGB_FreeSCCData(XPointer pScreenDataTemp);
+static int LINEAR_RGB_InitSCCData(Display *dpy,
+    int screenNumber, XcmsPerScrnInfo *pPerScrnInfo);
+static int XcmsLRGB_RGB_ParseString(register char *spec, XcmsColor *pColor);
+static int XcmsLRGB_RGBi_ParseString(register char *spec, XcmsColor *pColor);
+static Status
+_XcmsGetTableType0(
+    IntensityTbl *pTbl,
+    int	  format,
+    char **pChar,
+    unsigned long *pCount);
+static Status
+_XcmsGetTableType1(
+    IntensityTbl *pTbl,
+    int	  format,
+    char **pChar,
+    unsigned long *pCount);
+
+/*
+ *      LOCALS VARIABLES
+ *		Variables local to this package.
+ *		    Usage example:
+ *		        static int	ExampleLocalVar;
+ */
+
+static unsigned short const MASK[17] = {
+    0x0000,	/*  0 bitsPerRGB */
+    0x8000,	/*  1 bitsPerRGB */
+    0xc000,	/*  2 bitsPerRGB */
+    0xe000,	/*  3 bitsPerRGB */
+    0xf000,	/*  4 bitsPerRGB */
+    0xf800,	/*  5 bitsPerRGB */
+    0xfc00,	/*  6 bitsPerRGB */
+    0xfe00,	/*  7 bitsPerRGB */
+    0xff00,	/*  8 bitsPerRGB */
+    0xff80,	/*  9 bitsPerRGB */
+    0xffc0,	/* 10 bitsPerRGB */
+    0xffe0,	/* 11 bitsPerRGB */
+    0xfff0,	/* 12 bitsPerRGB */
+    0xfff8,	/* 13 bitsPerRGB */
+    0xfffc,	/* 14 bitsPerRGB */
+    0xfffe,	/* 15 bitsPerRGB */
+    0xffff	/* 16 bitsPerRGB */
+};
+
+
+    /*
+     * A NULL terminated array of function pointers that when applied
+     * in series will convert an XcmsColor structure from XcmsRGBFormat
+     * to XcmsCIEXYZFormat.
+     */
+static XcmsConversionProc Fl_RGB_to_CIEXYZ[] = {
+    (XcmsConversionProc)XcmsRGBToRGBi,
+    (XcmsConversionProc)XcmsRGBiToCIEXYZ,
+    NULL
+};
+
+    /*
+     * A NULL terminated array of function pointers that when applied
+     * in series will convert an XcmsColor structure from XcmsCIEXYZFormat
+     * to XcmsRGBFormat.
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_RGB[] = {
+    (XcmsConversionProc)XcmsCIEXYZToRGBi,
+    (XcmsConversionProc)XcmsRGBiToRGB,
+    NULL
+};
+
+    /*
+     * A NULL terminated array of function pointers that when applied
+     * in series will convert an XcmsColor structure from XcmsRGBiFormat
+     * to XcmsCIEXYZFormat.
+     */
+static XcmsConversionProc Fl_RGBi_to_CIEXYZ[] = {
+    (XcmsConversionProc)XcmsRGBiToCIEXYZ,
+    NULL
+};
+
+    /*
+     * A NULL terminated array of function pointers that when applied
+     * in series will convert an XcmsColor structure from XcmsCIEXYZFormat
+     * to XcmsRGBiFormat.
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_RGBi[] = {
+    (XcmsConversionProc)XcmsCIEXYZToRGBi,
+    NULL
+};
+
+    /*
+     * RGBi Color Spaces
+     */
+XcmsColorSpace	XcmsRGBiColorSpace =
+    {
+	_XcmsRGBi_prefix,	/* prefix */
+	XcmsRGBiFormat,		/* id */
+	XcmsLRGB_RGBi_ParseString,	/* parseString */
+	Fl_RGBi_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_RGBi,	/* from_CIEXYZ */
+	1
+    };
+
+    /*
+     * RGB Color Spaces
+     */
+XcmsColorSpace	XcmsRGBColorSpace =
+    {
+	_XcmsRGB_prefix,		/* prefix */
+	XcmsRGBFormat,		/* id */
+	XcmsLRGB_RGB_ParseString,	/* parseString */
+	Fl_RGB_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_RGB,	/* from_CIEXYZ */
+	1
+    };
+
+    /*
+     * Device-Independent Color Spaces known to the
+     * LINEAR_RGB Screen Color Characteristics Function Set.
+     */
+static XcmsColorSpace	*DDColorSpaces[] = {
+    &XcmsRGBColorSpace,
+    &XcmsRGBiColorSpace,
+    NULL
+};
+
+
+/*
+ *      GLOBALS
+ *              Variables declared in this package that are allowed
+ *		to be used globally.
+ */
+
+    /*
+     * LINEAR_RGB Screen Color Characteristics Function Set.
+     */
+XcmsFunctionSet	XcmsLinearRGBFunctionSet =
+    {
+	&DDColorSpaces[0],	/* pDDColorSpaces */
+	LINEAR_RGB_InitSCCData,	/* pInitScrnFunc */
+	LINEAR_RGB_FreeSCCData	/* pFreeSCCData */
+    };
+
+/*
+ *	DESCRIPTION
+ *		Contents of Default SCCData should be replaced if other
+ *		data should be used as default.
+ *
+ *
+ */
+
+/*
+ * NAME		Tektronix 19" (Sony) CRT
+ * PART_NUMBER		119-2451-00
+ * MODEL		Tek4300, Tek4800
+ */
+
+static IntensityRec const Default_RGB_RedTuples[] = {
+    /* {unsigned short value, XcmsFloat intensity} */
+            { 0x0000,    0.000000 },
+            { 0x0909,    0.000000 },
+            { 0x0a0a,    0.000936 },
+            { 0x0f0f,    0.001481 },
+            { 0x1414,    0.002329 },
+            { 0x1919,    0.003529 },
+            { 0x1e1e,    0.005127 },
+            { 0x2323,    0.007169 },
+            { 0x2828,    0.009699 },
+            { 0x2d2d,    0.012759 },
+            { 0x3232,    0.016392 },
+            { 0x3737,    0.020637 },
+            { 0x3c3c,    0.025533 },
+            { 0x4141,    0.031119 },
+            { 0x4646,    0.037431 },
+            { 0x4b4b,    0.044504 },
+            { 0x5050,    0.052373 },
+            { 0x5555,    0.061069 },
+            { 0x5a5a,    0.070624 },
+            { 0x5f5f,    0.081070 },
+            { 0x6464,    0.092433 },
+            { 0x6969,    0.104744 },
+            { 0x6e6e,    0.118026 },
+            { 0x7373,    0.132307 },
+            { 0x7878,    0.147610 },
+            { 0x7d7d,    0.163958 },
+            { 0x8282,    0.181371 },
+            { 0x8787,    0.199871 },
+            { 0x8c8c,    0.219475 },
+            { 0x9191,    0.240202 },
+            { 0x9696,    0.262069 },
+            { 0x9b9b,    0.285089 },
+            { 0xa0a0,    0.309278 },
+            { 0xa5a5,    0.334647 },
+            { 0xaaaa,    0.361208 },
+            { 0xafaf,    0.388971 },
+            { 0xb4b4,    0.417945 },
+            { 0xb9b9,    0.448138 },
+            { 0xbebe,    0.479555 },
+            { 0xc3c3,    0.512202 },
+            { 0xc8c8,    0.546082 },
+            { 0xcdcd,    0.581199 },
+            { 0xd2d2,    0.617552 },
+            { 0xd7d7,    0.655144 },
+            { 0xdcdc,    0.693971 },
+            { 0xe1e1,    0.734031 },
+            { 0xe6e6,    0.775322 },
+            { 0xebeb,    0.817837 },
+            { 0xf0f0,    0.861571 },
+            { 0xf5f5,    0.906515 },
+            { 0xfafa,    0.952662 },
+            { 0xffff,    1.000000 }
+};
+
+static IntensityRec const Default_RGB_GreenTuples[] = {
+    /* {unsigned short value, XcmsFloat intensity} */
+            { 0x0000,    0.000000 },
+            { 0x1313,    0.000000 },
+            { 0x1414,    0.000832 },
+            { 0x1919,    0.001998 },
+            { 0x1e1e,    0.003612 },
+            { 0x2323,    0.005736 },
+            { 0x2828,    0.008428 },
+            { 0x2d2d,    0.011745 },
+            { 0x3232,    0.015740 },
+            { 0x3737,    0.020463 },
+            { 0x3c3c,    0.025960 },
+            { 0x4141,    0.032275 },
+            { 0x4646,    0.039449 },
+            { 0x4b4b,    0.047519 },
+            { 0x5050,    0.056520 },
+            { 0x5555,    0.066484 },
+            { 0x5a5a,    0.077439 },
+            { 0x5f5f,    0.089409 },
+            { 0x6464,    0.102418 },
+            { 0x6969,    0.116485 },
+            { 0x6e6e,    0.131625 },
+            { 0x7373,    0.147853 },
+            { 0x7878,    0.165176 },
+            { 0x7d7d,    0.183604 },
+            { 0x8282,    0.203140 },
+            { 0x8787,    0.223783 },
+            { 0x8c8c,    0.245533 },
+            { 0x9191,    0.268384 },
+            { 0x9696,    0.292327 },
+            { 0x9b9b,    0.317351 },
+            { 0xa0a0,    0.343441 },
+            { 0xa5a5,    0.370580 },
+            { 0xaaaa,    0.398747 },
+            { 0xafaf,    0.427919 },
+            { 0xb4b4,    0.458068 },
+            { 0xb9b9,    0.489165 },
+            { 0xbebe,    0.521176 },
+            { 0xc3c3,    0.554067 },
+            { 0xc8c8,    0.587797 },
+            { 0xcdcd,    0.622324 },
+            { 0xd2d2,    0.657604 },
+            { 0xd7d7,    0.693588 },
+            { 0xdcdc,    0.730225 },
+            { 0xe1e1,    0.767459 },
+            { 0xe6e6,    0.805235 },
+            { 0xebeb,    0.843491 },
+            { 0xf0f0,    0.882164 },
+            { 0xf5f5,    0.921187 },
+            { 0xfafa,    0.960490 },
+            { 0xffff,    1.000000 }
+};
+
+static IntensityRec const Default_RGB_BlueTuples[] = {
+    /* {unsigned short value, XcmsFloat intensity} */
+            { 0x0000,    0.000000 },
+            { 0x0e0e,    0.000000 },
+            { 0x0f0f,    0.001341 },
+            { 0x1414,    0.002080 },
+            { 0x1919,    0.003188 },
+            { 0x1e1e,    0.004729 },
+            { 0x2323,    0.006766 },
+            { 0x2828,    0.009357 },
+            { 0x2d2d,    0.012559 },
+            { 0x3232,    0.016424 },
+            { 0x3737,    0.021004 },
+            { 0x3c3c,    0.026344 },
+            { 0x4141,    0.032489 },
+            { 0x4646,    0.039481 },
+            { 0x4b4b,    0.047357 },
+            { 0x5050,    0.056154 },
+            { 0x5555,    0.065903 },
+            { 0x5a5a,    0.076634 },
+            { 0x5f5f,    0.088373 },
+            { 0x6464,    0.101145 },
+            { 0x6969,    0.114968 },
+            { 0x6e6e,    0.129862 },
+            { 0x7373,    0.145841 },
+            { 0x7878,    0.162915 },
+            { 0x7d7d,    0.181095 },
+            { 0x8282,    0.200386 },
+            { 0x8787,    0.220791 },
+            { 0x8c8c,    0.242309 },
+            { 0x9191,    0.264937 },
+            { 0x9696,    0.288670 },
+            { 0x9b9b,    0.313499 },
+            { 0xa0a0,    0.339410 },
+            { 0xa5a5,    0.366390 },
+            { 0xaaaa,    0.394421 },
+            { 0xafaf,    0.423481 },
+            { 0xb4b4,    0.453547 },
+            { 0xb9b9,    0.484592 },
+            { 0xbebe,    0.516587 },
+            { 0xc3c3,    0.549498 },
+            { 0xc8c8,    0.583291 },
+            { 0xcdcd,    0.617925 },
+            { 0xd2d2,    0.653361 },
+            { 0xd7d7,    0.689553 },
+            { 0xdcdc,    0.726454 },
+            { 0xe1e1,    0.764013 },
+            { 0xe6e6,    0.802178 },
+            { 0xebeb,    0.840891 },
+            { 0xf0f0,    0.880093 },
+            { 0xf5f5,    0.919723 },
+            { 0xfafa,    0.959715 },
+	    { 0xffff,    1.00000 }
+};
+
+static IntensityTbl Default_RGB_RedTbl = {
+    /* IntensityRec *pBase */
+	(IntensityRec *) Default_RGB_RedTuples,
+    /* unsigned int nEntries */
+	52
+};
+
+static IntensityTbl Default_RGB_GreenTbl = {
+    /* IntensityRec *pBase */
+	(IntensityRec *)Default_RGB_GreenTuples,
+    /* unsigned int nEntries */
+	50
+};
+
+static IntensityTbl Default_RGB_BlueTbl = {
+    /* IntensityRec *pBase */
+	(IntensityRec *)Default_RGB_BlueTuples,
+    /* unsigned int nEntries */
+	51
+};
+
+static LINEAR_RGB_SCCData Default_RGB_SCCData = {
+    /* XcmsFloat XYZtoRGBmatrix[3][3] */
+  {
+    { 3.48340481253539000, -1.52176374927285200, -0.55923133354049780 },
+    {-1.07152751306193600,  1.96593795204372400,  0.03673691339553462 },
+    { 0.06351179790497788, -0.20020501000496480,  0.81070942031648220 }
+  },
+
+    /* XcmsFloat RGBtoXYZmatrix[3][3] */
+  {
+    { 0.38106149108714790, 0.32025712365352110, 0.24834578525933100 },
+    { 0.20729745115140850, 0.68054638776373240, 0.11215616108485920 },
+    { 0.02133944350088028, 0.14297193020246480, 1.24172892629665500 }
+  },
+
+    /* IntensityTbl *pRedTbl */
+	&Default_RGB_RedTbl,
+
+    /* IntensityTbl *pGreenTbl */
+	&Default_RGB_GreenTbl,
+
+    /* IntensityTbl *pBlueTbl */
+	&Default_RGB_BlueTbl
+};
+
+/************************************************************************
+ *									*
+ *			PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		LINEAR_RGB_InitSCCData()
+ *
+ *	SYNOPSIS
+ */
+static Status
+LINEAR_RGB_InitSCCData(
+    Display *dpy,
+    int screenNumber,
+    XcmsPerScrnInfo *pPerScrnInfo)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		XcmsFailure if failed.
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    Atom  CorrectAtom = XInternAtom (dpy, XDCCC_CORRECT_ATOM_NAME, True);
+    Atom  MatrixAtom  = XInternAtom (dpy, XDCCC_MATRIX_ATOM_NAME, True);
+    int	  format_return, count, cType, nTables;
+    unsigned long nitems, nbytes_return;
+    char *property_return, *pChar;
+    XcmsFloat *pValue;
+#ifdef ALLDEBUG
+    IntensityRec *pIRec;
+#endif /* ALLDEBUG */
+    VisualID visualID;
+
+    LINEAR_RGB_SCCData *pScreenData, *pScreenDefaultData;
+    XcmsIntensityMap *pNewMap;
+
+    /*
+     * Allocate memory for pScreenData
+     */
+    if (!(pScreenData = pScreenDefaultData = (LINEAR_RGB_SCCData *)
+		      Xcalloc (1, sizeof(LINEAR_RGB_SCCData)))) {
+	return(XcmsFailure);
+    }
+
+    /*
+     *  1. Get the XYZ->RGB and RGB->XYZ matrices
+     */
+
+    if (MatrixAtom == None ||
+	!_XcmsGetProperty (dpy, RootWindow(dpy, screenNumber), MatrixAtom,
+	   &format_return, &nitems, &nbytes_return, &property_return) ||
+	   nitems != 18 || format_return != 32) {
+	/*
+	 * As per the XDCCC, there must be 18 data items and each must be
+	 * in 32 bits !
+	 */
+	goto FreeSCCData;
+
+    } else {
+
+	/*
+	 * RGBtoXYZ and XYZtoRGB matrices
+	 */
+	pValue = (XcmsFloat *) pScreenData;
+	pChar = property_return;
+	for (count = 0; count < 18; count++) {
+	    *pValue++ = (long)_XcmsGetElement(format_return, &pChar,
+		    &nitems) / (XcmsFloat)XDCCC_NUMBER;
+	}
+	Xfree ((char *)property_return);
+	pPerScrnInfo->screenWhitePt.spec.CIEXYZ.X =
+		pScreenData->RGBtoXYZmatrix[0][0] +
+		pScreenData->RGBtoXYZmatrix[0][1] +
+		pScreenData->RGBtoXYZmatrix[0][2];
+	pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y =
+		pScreenData->RGBtoXYZmatrix[1][0] +
+		pScreenData->RGBtoXYZmatrix[1][1] +
+		pScreenData->RGBtoXYZmatrix[1][2];
+	pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Z =
+		pScreenData->RGBtoXYZmatrix[2][0] +
+		pScreenData->RGBtoXYZmatrix[2][1] +
+		pScreenData->RGBtoXYZmatrix[2][2];
+
+	/*
+	 * Compute the Screen White Point
+	 */
+	if ((pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y < (1.0 - EPS) )
+		|| (pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y > (1.0 + EPS))) {
+	    goto FreeSCCData;
+	} else {
+	    pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y = 1.0;
+	}
+	pPerScrnInfo->screenWhitePt.format = XcmsCIEXYZFormat;
+	pPerScrnInfo->screenWhitePt.pixel = 0;
+
+#ifdef PDEBUG
+	printf ("RGB to XYZ Matrix values:\n");
+	printf ("       %f %f %f\n       %f %f %f\n       %f %f %f\n",
+		pScreenData->RGBtoXYZmatrix[0][0],
+		pScreenData->RGBtoXYZmatrix[0][1],
+		pScreenData->RGBtoXYZmatrix[0][2],
+		pScreenData->RGBtoXYZmatrix[1][0],
+		pScreenData->RGBtoXYZmatrix[1][1],
+		pScreenData->RGBtoXYZmatrix[1][2],
+		pScreenData->RGBtoXYZmatrix[2][0],
+		pScreenData->RGBtoXYZmatrix[2][1],
+		pScreenData->RGBtoXYZmatrix[2][2]);
+	printf ("XYZ to RGB Matrix values:\n");
+	printf ("       %f %f %f\n       %f %f %f\n       %f %f %f\n",
+		pScreenData->XYZtoRGBmatrix[0][0],
+		pScreenData->XYZtoRGBmatrix[0][1],
+		pScreenData->XYZtoRGBmatrix[0][2],
+		pScreenData->XYZtoRGBmatrix[1][0],
+		pScreenData->XYZtoRGBmatrix[1][1],
+		pScreenData->XYZtoRGBmatrix[1][2],
+		pScreenData->XYZtoRGBmatrix[2][0],
+		pScreenData->XYZtoRGBmatrix[2][1],
+		pScreenData->XYZtoRGBmatrix[2][2]);
+	printf ("Screen White Pt value: %f %f %f\n",
+		pPerScrnInfo->screenWhitePt.spec.CIEXYZ.X,
+		pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y,
+		pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Z);
+#endif /* PDEBUG */
+    }
+
+    /*
+     *	2. Get the Intensity Profile
+     */
+    if (CorrectAtom == None ||
+	!_XcmsGetProperty (dpy, RootWindow(dpy, screenNumber), CorrectAtom,
+	   &format_return, &nitems, &nbytes_return, &property_return)) {
+	Xfree ((char *)property_return);
+	goto FreeSCCData;
+    }
+
+    pChar = property_return;
+
+    while (nitems) {
+	switch (format_return) {
+	  case 8:
+	    /*
+	     * Must have at least:
+	     *		VisualID0
+	     *		VisualID1
+	     *		VisualID2
+	     *		VisualID3
+	     *		type
+	     *		count
+	     *		length
+	     *		intensity1
+	     *		intensity2
+	     */
+	    if (nitems < 9) {
+		Xfree ((char *)property_return);
+		goto FreeSCCData;
+	    }
+	    count = 3;
+	    break;
+	  case 16:
+	    /*
+	     * Must have at least:
+	     *		VisualID0
+	     *		VisualID3
+	     *		type
+	     *		count
+	     *		length
+	     *		intensity1
+	     *		intensity2
+	     */
+	    if (nitems < 7) {
+		Xfree ((char *)property_return);
+		goto FreeSCCData;
+	    }
+	    count = 1;
+	    break;
+	  case 32:
+	    /*
+	     * Must have at least:
+	     *		VisualID0
+	     *		type
+	     *		count
+	     *		length
+	     *		intensity1
+	     *		intensity2
+	     */
+	    if (nitems < 6) {
+		Xfree ((char *)property_return);
+		goto FreeSCCData;
+	    }
+	    count = 0;
+	    break;
+	  default:
+	    Xfree ((char *)property_return);
+	    goto FreeSCCData;
+	}
+
+	/*
+	 * Get VisualID
+	 */
+	visualID = _XcmsGetElement(format_return, &pChar, &nitems);
+	while (count--) {
+	    visualID = visualID << format_return;
+	    visualID |= _XcmsGetElement(format_return, &pChar, &nitems);
+	}
+
+	if (visualID == 0) {
+	    /*
+	     * This is a shared intensity table
+	     */
+	    pScreenData = pScreenDefaultData;
+	} else {
+	    /*
+	     * This is a per-Visual intensity table
+	     */
+	    if (!(pScreenData = (LINEAR_RGB_SCCData *)
+			      Xcalloc (1, sizeof(LINEAR_RGB_SCCData)))) {
+		return(XcmsFailure);
+	    }
+	    /* copy matrices */
+	    memcpy((char *)pScreenData, (char *)pScreenDefaultData,
+		   18 * sizeof(XcmsFloat));
+
+	    /* Create, initialize, and add map */
+	    if (!(pNewMap = (XcmsIntensityMap *)
+			      Xcalloc (1, sizeof(XcmsIntensityMap)))) {
+		Xfree((char *)pScreenData);
+		return(XcmsFailure);
+	    }
+	    pNewMap->visualID = visualID;
+	    pNewMap->screenData = (XPointer)pScreenData;
+	    pNewMap->pFreeScreenData = LINEAR_RGB_FreeSCCData;
+	    pNewMap->pNext =
+		    (XcmsIntensityMap *)dpy->cms.perVisualIntensityMaps;
+	    dpy->cms.perVisualIntensityMaps = (XPointer)pNewMap;
+	    dpy->free_funcs->intensityMaps = _XcmsFreeIntensityMaps;
+	}
+
+	cType = _XcmsGetElement(format_return, &pChar, &nitems);
+	nTables = _XcmsGetElement(format_return, &pChar, &nitems);
+
+	if (cType == 0) {
+
+	    /* Red Intensity Table */
+	    if (!(pScreenData->pRedTbl = (IntensityTbl *)
+		    Xcalloc (1, sizeof(IntensityTbl)))) {
+		goto FreeSCCData;
+	    }
+	    if (_XcmsGetTableType0(pScreenData->pRedTbl, format_return, &pChar,
+		    &nitems) == XcmsFailure) {
+		goto FreeRedTbl;
+	    }
+
+	    if (nTables == 1) {
+		/* Green Intensity Table */
+		pScreenData->pGreenTbl = pScreenData->pRedTbl;
+		/* Blue Intensity Table */
+		pScreenData->pBlueTbl = pScreenData->pRedTbl;
+	    } else {
+		/* Green Intensity Table */
+		if (!(pScreenData->pGreenTbl = (IntensityTbl *)
+			Xcalloc (1, sizeof(IntensityTbl)))) {
+		    goto FreeRedTblElements;
+		}
+		if (_XcmsGetTableType0(pScreenData->pGreenTbl, format_return, &pChar,
+			&nitems) == XcmsFailure) {
+		    goto FreeGreenTbl;
+		}
+
+		/* Blue Intensity Table */
+		if (!(pScreenData->pBlueTbl = (IntensityTbl *)
+			Xcalloc (1, sizeof(IntensityTbl)))) {
+		    goto FreeGreenTblElements;
+		}
+		if (_XcmsGetTableType0(pScreenData->pBlueTbl, format_return, &pChar,
+			&nitems) == XcmsFailure) {
+		    goto FreeBlueTbl;
+		}
+	    }
+	} else if (cType == 1) {
+	    /* Red Intensity Table */
+	    if (!(pScreenData->pRedTbl = (IntensityTbl *)
+		    Xcalloc (1, sizeof(IntensityTbl)))) {
+		goto FreeSCCData;
+	    }
+	    if (_XcmsGetTableType1(pScreenData->pRedTbl, format_return, &pChar,
+		    &nitems) == XcmsFailure) {
+		goto FreeRedTbl;
+	    }
+
+	    if (nTables == 1) {
+
+		/* Green Intensity Table */
+		pScreenData->pGreenTbl = pScreenData->pRedTbl;
+		/* Blue Intensity Table */
+		pScreenData->pBlueTbl = pScreenData->pRedTbl;
+
+	    } else {
+
+		/* Green Intensity Table */
+		if (!(pScreenData->pGreenTbl = (IntensityTbl *)
+			Xcalloc (1, sizeof(IntensityTbl)))) {
+		    goto FreeRedTblElements;
+		}
+		if (_XcmsGetTableType1(pScreenData->pGreenTbl, format_return, &pChar,
+			&nitems) == XcmsFailure) {
+		    goto FreeGreenTbl;
+		}
+
+		/* Blue Intensity Table */
+		if (!(pScreenData->pBlueTbl = (IntensityTbl *)
+			Xcalloc (1, sizeof(IntensityTbl)))) {
+		    goto FreeBlueTblElements;
+		}
+		if (_XcmsGetTableType1(pScreenData->pBlueTbl, format_return, &pChar,
+			&nitems) == XcmsFailure) {
+		    goto FreeBlueTbl;
+		}
+	    }
+	} else {
+	    Xfree ((char *)property_return);
+	    goto FreeSCCData;
+	}
+
+#ifdef ALLDEBUG
+	printf ("Intensity Table  RED    %d\n", pScreenData->pRedTbl->nEntries);
+	pIRec = (IntensityRec *) pScreenData->pRedTbl->pBase;
+	for (count = 0; count < pScreenData->pRedTbl->nEntries; count++, pIRec++) {
+	    printf ("\t0x%4x\t%f\n", pIRec->value, pIRec->intensity);
+	}
+	if (pScreenData->pGreenTbl->pBase != pScreenData->pRedTbl->pBase) {
+	    printf ("Intensity Table  GREEN  %d\n", pScreenData->pGreenTbl->nEntries);
+	    pIRec = (IntensityRec *)pScreenData->pGreenTbl->pBase;
+	    for (count = 0; count < pScreenData->pGreenTbl->nEntries; count++, pIRec++) {
+		printf ("\t0x%4x\t%f\n", pIRec->value, pIRec->intensity);
+	    }
+	}
+	if (pScreenData->pBlueTbl->pBase != pScreenData->pRedTbl->pBase) {
+	    printf ("Intensity Table  BLUE   %d\n", pScreenData->pBlueTbl->nEntries);
+	    pIRec = (IntensityRec *) pScreenData->pBlueTbl->pBase;
+	    for (count = 0; count < pScreenData->pBlueTbl->nEntries; count++, pIRec++) {
+		printf ("\t0x%4x\t%f\n", pIRec->value, pIRec->intensity);
+	    }
+	}
+#endif /* ALLDEBUG */
+    }
+
+    Xfree ((char *)property_return);
+
+    /* Free the old memory and use the new structure created. */
+    LINEAR_RGB_FreeSCCData(pPerScrnInfo->screenData);
+
+    pPerScrnInfo->functionSet = (XPointer) &XcmsLinearRGBFunctionSet;
+
+    pPerScrnInfo->screenData = (XPointer) pScreenData;
+
+    pPerScrnInfo->state = XcmsInitSuccess;
+
+    return(XcmsSuccess);
+
+FreeBlueTblElements:
+    Xfree((char *)pScreenData->pBlueTbl->pBase);
+
+FreeBlueTbl:
+    Xfree((char *)pScreenData->pBlueTbl);
+
+FreeGreenTblElements:
+    Xfree((char *)pScreenData->pBlueTbl->pBase);
+
+FreeGreenTbl:
+    Xfree((char *)pScreenData->pGreenTbl);
+
+FreeRedTblElements:
+    Xfree((char *)pScreenData->pRedTbl->pBase);
+
+FreeRedTbl:
+    Xfree((char *)pScreenData->pRedTbl);
+
+FreeSCCData:
+    Xfree((char *)pScreenData);
+    pPerScrnInfo->state = XcmsInitNone;
+    return(XcmsFailure);
+}
+
+
+/*
+ *	NAME
+ *		LINEAR_RGB_FreeSCCData()
+ *
+ *	SYNOPSIS
+ */
+static void
+LINEAR_RGB_FreeSCCData(
+    XPointer pScreenDataTemp)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		0 if failed.
+ *		1 if succeeded with no modifications.
+ *
+ */
+{
+    LINEAR_RGB_SCCData *pScreenData = (LINEAR_RGB_SCCData *) pScreenDataTemp;
+
+    if (pScreenData && pScreenData != &Default_RGB_SCCData) {
+	if (pScreenData->pRedTbl) {
+	    if (pScreenData->pGreenTbl) {
+		if (pScreenData->pRedTbl->pBase !=
+		    pScreenData->pGreenTbl->pBase) {
+		    if (pScreenData->pGreenTbl->pBase) {
+			Xfree ((char *)pScreenData->pGreenTbl->pBase);
+		    }
+		}
+		if (pScreenData->pGreenTbl != pScreenData->pRedTbl) {
+		    Xfree ((char *)pScreenData->pGreenTbl);
+		}
+	    }
+	    if (pScreenData->pBlueTbl) {
+		if (pScreenData->pRedTbl->pBase !=
+		    pScreenData->pBlueTbl->pBase) {
+		    if (pScreenData->pBlueTbl->pBase) {
+			Xfree ((char *)pScreenData->pBlueTbl->pBase);
+		    }
+		}
+		if (pScreenData->pBlueTbl != pScreenData->pRedTbl) {
+		    Xfree ((char *)pScreenData->pBlueTbl);
+		}
+	    }
+	    if (pScreenData->pRedTbl->pBase) {
+		Xfree ((char *)pScreenData->pRedTbl->pBase);
+	    }
+	    Xfree ((char *)pScreenData->pRedTbl);
+	}
+	Xfree ((char *)pScreenData);
+    }
+}
+
+
+
+/************************************************************************
+ *									*
+ *			API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsGetTableType0
+ *
+ *	SYNOPSIS
+ */
+static Status
+_XcmsGetTableType0(
+    IntensityTbl *pTbl,
+    int	  format,
+    char **pChar,
+    unsigned long *pCount)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		XcmsFailure if failed.
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    unsigned int nElements;
+    IntensityRec *pIRec;
+
+    nElements = pTbl->nEntries =
+	    _XcmsGetElement(format, pChar, pCount) + 1;
+    if (!(pIRec = pTbl->pBase = (IntensityRec *)
+	  Xcalloc (nElements, sizeof(IntensityRec)))) {
+	return(XcmsFailure);
+    }
+
+    switch (format) {
+      case 8:
+	for (; nElements--; pIRec++) {
+	    /* 0xFFFF/0xFF = 0x101 */
+	    pIRec->value = _XcmsGetElement (format, pChar, pCount) * 0x101;
+	    pIRec->intensity =
+		    _XcmsGetElement (format, pChar, pCount) / (XcmsFloat)255.0;
+	}
+	break;
+      case 16:
+	for (; nElements--; pIRec++) {
+	    pIRec->value = _XcmsGetElement (format, pChar, pCount);
+	    pIRec->intensity = _XcmsGetElement (format, pChar, pCount)
+		    / (XcmsFloat)65535.0;
+	}
+	break;
+      case 32:
+	for (; nElements--; pIRec++) {
+	    pIRec->value = _XcmsGetElement (format, pChar, pCount);
+	    pIRec->intensity = _XcmsGetElement (format, pChar, pCount)
+		    / (XcmsFloat)4294967295.0;
+	}
+	break;
+      default:
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsGetTableType1
+ *
+ *	SYNOPSIS
+ */
+static Status
+_XcmsGetTableType1(
+    IntensityTbl *pTbl,
+    int	  format,
+    char **pChar,
+    unsigned long *pCount)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		XcmsFailure if failed.
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    int count;
+    unsigned int max_index;
+    IntensityRec *pIRec;
+
+    max_index = _XcmsGetElement(format, pChar, pCount);
+    pTbl->nEntries = max_index + 1;
+    if (!(pIRec = pTbl->pBase = (IntensityRec *)
+	  Xcalloc (max_index+1, sizeof(IntensityRec)))) {
+	return(XcmsFailure);
+    }
+
+    switch (format) {
+      case 8:
+	for (count = 0; count < max_index+1; count++, pIRec++) {
+	    pIRec->value = (count * 65535) / max_index;
+	    pIRec->intensity = _XcmsGetElement (format, pChar, pCount)
+		    / (XcmsFloat)255.0;
+	}
+	break;
+      case 16:
+	for (count = 0; count < max_index+1; count++, pIRec++) {
+	    pIRec->value = (count * 65535) / max_index;
+	    pIRec->intensity = _XcmsGetElement (format, pChar, pCount)
+		    / (XcmsFloat)65535.0;
+	}
+	break;
+      case 32:
+	for (count = 0; count < max_index+1; count++, pIRec++) {
+	    pIRec->value = (count * 65535) / max_index;
+	    pIRec->intensity = _XcmsGetElement (format, pChar, pCount)
+		    / (XcmsFloat)4294967295.0;
+	}
+	break;
+      default:
+	return(XcmsFailure);
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		ValueCmp
+ *
+ *	SYNOPSIS
+ */
+static int
+_XcmsValueCmp(
+    IntensityRec *p1, IntensityRec *p2)
+/*
+ *	DESCRIPTION
+ *		Compares the value component of two IntensityRec
+ *		structures.
+ *
+ *	RETURNS
+ *		0 if p1->value is equal to p2->value
+ *		< 0 if p1->value is less than p2->value
+ *		> 0 if p1->value is greater than p2->value
+ *
+ */
+{
+    return (p1->value - p2->value);
+}
+
+
+/*
+ *	NAME
+ *		IntensityCmp
+ *
+ *	SYNOPSIS
+ */
+static int
+_XcmsIntensityCmp(
+    IntensityRec *p1, IntensityRec *p2)
+/*
+ *	DESCRIPTION
+ *		Compares the intensity component of two IntensityRec
+ *		structures.
+ *
+ *	RETURNS
+ *		0 if equal;
+ *		< 0 if first precedes second
+ *		> 0 if first succeeds second
+ *
+ */
+{
+    if (p1->intensity < p2->intensity) {
+	return (-1);
+    }
+    if (p1->intensity > p2->intensity) {
+	return (XcmsSuccess);
+    }
+    return (XcmsFailure);
+}
+
+/*
+ *	NAME
+ *		ValueInterpolation
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+static int
+_XcmsValueInterpolation(
+    IntensityRec *key, IntensityRec *lo, IntensityRec *hi, IntensityRec *answer,
+    int bitsPerRGB)
+/*
+ *	DESCRIPTION
+ *		Based on a given value, performs a linear interpolation
+ *		on the intensities between two IntensityRec structures.
+ *		Note that the bitsPerRGB parameter is ignored.
+ *
+ *	RETURNS
+ *		Returns 0 if failed; otherwise non-zero.
+ */
+{
+    XcmsFloat ratio;
+
+    ratio = ((XcmsFloat)key->value - (XcmsFloat)lo->value) /
+	((XcmsFloat)hi->value - (XcmsFloat)lo->value);
+    answer->value = key->value;
+    answer->intensity = (hi->intensity - lo->intensity) * ratio;
+    answer->intensity += lo->intensity;
+    return (XcmsSuccess);
+}
+
+/*
+ *	NAME
+ *		IntensityInterpolation
+ *
+ *	SYNOPSIS
+ */
+static int
+_XcmsIntensityInterpolation(
+    IntensityRec *key, IntensityRec *lo, IntensityRec *hi, IntensityRec *answer,
+    int bitsPerRGB)
+/*
+ *	DESCRIPTION
+ *		Based on a given intensity, performs a linear interpolation
+ *		on the values between two IntensityRec structures.
+ *		The bitsPerRGB parameter is necessary to perform rounding
+ *		to the correct number of significant bits.
+ *
+ *	RETURNS
+ *		Returns 0 if failed; otherwise non-zero.
+ */
+{
+    XcmsFloat ratio;
+    long target, up, down;
+    int shift = 16 - bitsPerRGB;
+    int max_color = (1 << bitsPerRGB) - 1;
+
+    ratio = (key->intensity - lo->intensity) / (hi->intensity - lo->intensity);
+    answer->intensity = key->intensity;
+    target = hi->value - lo->value;
+    target *= ratio;
+    target += lo->value;
+
+    /*
+     * Ok now, lets find the closest in respects to bits per RGB
+     */
+    up = ((target >> shift) * 0xFFFF) / max_color;
+    if (up < target) {
+	down = up;
+	up = (MIN((down >> shift) + 1, max_color) * 0xFFFF) / max_color;
+    } else {
+	down = (MAX((up >> shift) - 1, 0) * 0xFFFF) / max_color;
+    }
+    answer->value = ((up - target) < (target - down) ? up : down);
+    answer->value &= MASK[bitsPerRGB];
+    return (XcmsSuccess);
+}
+
+
+
+typedef int (*comparProcp)(
+    char *p1,
+    char *p2);
+typedef int (*interpolProcp)(
+    char *key,
+    char *lo,
+    char *hi,
+    char *answer,
+    int bitsPerRGB);
+
+/*
+ *	NAME
+ *		_XcmsTableSearch
+ *
+ *	SYNOPSIS
+ */
+static int
+_XcmsTableSearch(
+    char *key,
+    int bitsPerRGB,
+    char *base,
+    unsigned nel,
+    unsigned nKeyPtrSize,
+    int (*compar)(
+        char *p1,
+        char *p2),
+    int (*interpol)(
+        char *key,
+        char *lo,
+        char *hi,
+        char *answer,
+        int bitsPerRGB),
+    char *answer)
+
+/*
+ *	DESCRIPTION
+ *		A binary search through the specificied table.
+ *
+ *	RETURNS
+ *		Returns 0 if failed; otherwise non-zero.
+ *
+ */
+{
+    char *hi, *lo, *mid, *last;
+    int result;
+
+    last = hi = base + ((nel - 1) * nKeyPtrSize);
+    mid = lo = base;
+
+    /* use only the significants bits, then scale into 16 bits */
+    ((IntensityRec *)key)->value = ((unsigned long)
+	    (((IntensityRec *)key)->value >> (16 - bitsPerRGB)) * 0xFFFF)
+	    / ((1 << bitsPerRGB) - 1);
+
+    /* Special case so that zero intensity always maps to zero value */
+    if ((*compar) (key,lo) <= 0) {
+	memcpy (answer, lo, nKeyPtrSize);
+	((IntensityRec *)answer)->value &= MASK[bitsPerRGB];
+	return XcmsSuccess;
+    }
+    while (mid != last) {
+	last = mid;
+	mid = lo + (((unsigned)(hi - lo) / nKeyPtrSize) / 2) * nKeyPtrSize;
+	result = (*compar) (key, mid);
+	if (result == 0) {
+
+	    memcpy(answer, mid, nKeyPtrSize);
+	    ((IntensityRec *)answer)->value &= MASK[bitsPerRGB];
+	    return (XcmsSuccess);
+	} else if (result < 0) {
+	    hi = mid;
+	} else {
+	    lo = mid;
+	}
+    }
+
+    /*
+     * If we got to here, we didn't find a solution, so we
+     * need to apply interpolation.
+     */
+    return ((*interpol)(key, lo, hi, answer, bitsPerRGB));
+}
+
+
+/*
+ *      NAME
+ *		_XcmsMatVec - multiply a 3 x 3 by a 3 x 1 vector
+ *
+ *	SYNOPSIS
+ */
+static void _XcmsMatVec(
+    XcmsFloat *pMat, XcmsFloat *pIn, XcmsFloat *pOut)
+/*
+ *      DESCRIPTION
+ *		Multiply the passed vector by the passed matrix to return a
+ *		vector. Matrix is 3x3, vectors are of length 3.
+ *
+ *	RETURNS
+ *		void
+ */
+{
+    int i, j;
+
+    for (i = 0; i < 3; i++) {
+	pOut[i] = 0.0;
+	for (j = 0; j < 3; j++)
+	    pOut[i] += *(pMat+(i*3)+j) * pIn[j];
+    }
+}
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+
+/*
+ *	NAME
+ *		XcmsLRGB_RGB_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+XcmsLRGB_RGB_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsRGBFormat.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    register int n, i;
+    unsigned short r, g, b;
+    char c;
+    char *pchar;
+    unsigned short *pShort;
+
+    /*
+     * Check for old # format
+     */
+    if (*spec == '#') {
+	/*
+	 * Attempt to parse the value portion.
+	 */
+	spec++;
+	n = strlen(spec);
+	if (n != 3 && n != 6 && n != 9 && n != 12) {
+	    return(XcmsFailure);
+	}
+
+	n /= 3;
+	g = b = 0;
+	do {
+	    r = g;
+	    g = b;
+	    b = 0;
+	    for (i = n; --i >= 0; ) {
+		c = *spec++;
+		b <<= 4;
+		if (c >= '0' && c <= '9')
+		    b |= c - '0';
+		/* assume string in lowercase
+		else if (c >= 'A' && c <= 'F')
+		    b |= c - ('A' - 10);
+		*/
+		else if (c >= 'a' && c <= 'f')
+		    b |= c - ('a' - 10);
+		else return (XcmsFailure);
+	    }
+	} while (*spec != '\0');
+
+	/*
+	 * Succeeded !
+	 */
+	n <<= 2;
+	n = 16 - n;
+	/* shift instead of scale, to match old broken semantics */
+	pColor->spec.RGB.red = r << n;
+	pColor->spec.RGB.green = g << n;
+	pColor->spec.RGB.blue =  b << n;
+    } else {
+	if ((pchar = strchr(spec, ':')) == NULL) {
+	    return(XcmsFailure);
+	}
+	n = (int)(pchar - spec);
+
+	/*
+	 * Check for proper prefix.
+	 */
+	if (strncmp(spec, _XcmsRGB_prefix, n) != 0) {
+	    return(XcmsFailure);
+	}
+
+	/*
+	 * Attempt to parse the value portion.
+	 */
+	spec += (n + 1);
+	pShort = &pColor->spec.RGB.red;
+	for (i = 0; i < 3; i++, pShort++, spec++) {
+	    n = 0;
+	    *pShort = 0;
+	    while (*spec != '/' && *spec != '\0') {
+		if (++n > 4) {
+		    return(XcmsFailure);
+		}
+		c = *spec++;
+		*pShort <<= 4;
+		if (c >= '0' && c <= '9')
+		    *pShort |= c - '0';
+		/* assume string in lowercase
+		else if (c >= 'A' && c <= 'F')
+		    *pShort |= c - ('A' - 10);
+		*/
+		else if (c >= 'a' && c <= 'f')
+		    *pShort |= c - ('a' - 10);
+		else return (XcmsFailure);
+	    }
+	    if (n == 0)
+		return (XcmsFailure);
+	    if (n < 4) {
+		*pShort = ((unsigned long)*pShort * 0xFFFF) / ((1 << n*4) - 1);
+	    }
+	}
+    }
+    pColor->format = XcmsRGBFormat;
+    pColor->pixel = 0;
+    return (XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsLRGB_RGBi_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+XcmsLRGB_RGBi_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsRGBiFormat.
+ *		The assumed RGBi string syntax is:
+ *		    RGBi:<r>/<g>/<b>
+ *		Where r, g, and b are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsRGBi_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.RGBi.red,
+	    &pColor->spec.RGBi.green,
+	    &pColor->spec.RGBi.blue) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.RGBi.red,
+		       &pColor->spec.RGBi.green,
+		       &pColor->spec.RGBi.blue) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	    return(XcmsFailure);
+    }
+
+    /*
+     * Succeeded !
+     */
+    pColor->format = XcmsRGBiFormat;
+    pColor->pixel = 0;
+    return (XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEXYZToRGBi - convert CIE XYZ to RGB
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsCIEXYZToRGBi(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColors_in_out,/* pointer to XcmsColors to convert 	*/
+    unsigned int nColors,	/* Number of colors			*/
+    Bool *pCompressed)		/* pointer to an array of Bool		*/
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from RGB format to RGBi format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded without gamut compression.
+ *		XcmsSuccessWithCompression if succeeded with gamut
+ *			compression.
+ */
+{
+    LINEAR_RGB_SCCData *pScreenData;
+    XcmsFloat tmp[3];
+    int hasCompressed = 0;
+    unsigned int i;
+    XcmsColor *pColor = pXcmsColors_in_out;
+
+    if (ccc == NULL) {
+	return(XcmsFailure);
+    }
+
+    pScreenData = (LINEAR_RGB_SCCData *)ccc->pPerScrnInfo->screenData;
+
+    /*
+     * XcmsColors should be White Point Adjusted, if necessary, by now!
+     */
+
+    /*
+     * NEW!!! for extended gamut compression
+     *
+     * 1. Need to zero out pCompressed
+     *
+     * 2. Need to save initial address of pColor
+     *
+     * 3. Need to save initial address of pCompressed
+     */
+
+    for (i = 0; i < nColors; i++) {
+
+	/* Make sure format is XcmsCIEXYZFormat */
+	if (pColor->format != XcmsCIEXYZFormat) {
+	    return(XcmsFailure);
+	}
+
+	/* Multiply [A]-1 * [XYZ] to get RGB intensity */
+	_XcmsMatVec((XcmsFloat *) pScreenData->XYZtoRGBmatrix,
+		(XcmsFloat *) &pColor->spec, tmp);
+
+	if ((MIN3 (tmp[0], tmp[1], tmp[2]) < -EPS) ||
+	    (MAX3 (tmp[0], tmp[1], tmp[2]) > (1.0 + EPS))) {
+
+	    /*
+	     * RGBi out of screen's gamut
+	     */
+
+	    if (ccc->gamutCompProc == NULL) {
+		/*
+		 * Aha!! Here's that little trick that will allow
+		 * gamut compression routines to get the out of bound
+		 * RGBi.
+		 */
+		memcpy((char *)&pColor->spec, (char *)tmp, sizeof(tmp));
+		pColor->format = XcmsRGBiFormat;
+		return(XcmsFailure);
+	    } else if ((*ccc->gamutCompProc)(ccc, pXcmsColors_in_out, nColors,
+		    i, pCompressed) == 0) {
+		return(XcmsFailure);
+	    }
+
+	    /*
+	     * The gamut compression function should return colors in CIEXYZ
+	     *	Also check again to if the new color is within gamut.
+	     */
+	    if (pColor->format != XcmsCIEXYZFormat) {
+		return(XcmsFailure);
+	    }
+	    _XcmsMatVec((XcmsFloat *) pScreenData->XYZtoRGBmatrix,
+		    (XcmsFloat *) &pColor->spec, tmp);
+	    if ((MIN3 (tmp[0], tmp[1], tmp[2]) < -EPS) ||
+		(MAX3 (tmp[0], tmp[1], tmp[2]) > (1.0 + EPS))) {
+		return(XcmsFailure);
+	    }
+	    hasCompressed++;
+	}
+	memcpy((char *)&pColor->spec, (char *)tmp, sizeof(tmp));
+	/* These if statements are done to ensure the fudge factor is */
+	/* is taken into account. */
+	if (pColor->spec.RGBi.red < 0.0) {
+		pColor->spec.RGBi.red = 0.0;
+	} else if (pColor->spec.RGBi.red > 1.0) {
+		pColor->spec.RGBi.red = 1.0;
+	}
+	if (pColor->spec.RGBi.green < 0.0) {
+		pColor->spec.RGBi.green = 0.0;
+	} else if (pColor->spec.RGBi.green > 1.0) {
+		pColor->spec.RGBi.green = 1.0;
+	}
+	if (pColor->spec.RGBi.blue < 0.0) {
+		pColor->spec.RGBi.blue = 0.0;
+	} else if (pColor->spec.RGBi.blue > 1.0) {
+		pColor->spec.RGBi.blue = 1.0;
+	}
+	(pColor++)->format = XcmsRGBiFormat;
+    }
+    return (hasCompressed ? XcmsSuccessWithCompression : XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		LINEAR_RGBi_to_CIEXYZ - convert RGBi to CIEXYZ
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsRGBiToCIEXYZ(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColors_in_out,/* pointer to XcmsColors to convert 	*/
+    unsigned int nColors,	/* Number of colors			*/
+    Bool *pCompressed)		/* pointer to a bit array		*/
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from RGBi format to CIEXYZ format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ */
+{
+    LINEAR_RGB_SCCData *pScreenData;
+    XcmsFloat tmp[3];
+
+    /*
+     * pCompressed ignored in this function.
+     */
+
+    if (ccc == NULL) {
+	return(XcmsFailure);
+    }
+
+    pScreenData = (LINEAR_RGB_SCCData *)ccc->pPerScrnInfo->screenData;
+
+    /*
+     * XcmsColors should be White Point Adjusted, if necessary, by now!
+     */
+
+    while (nColors--) {
+
+	/* Multiply [A]-1 * [XYZ] to get RGB intensity */
+	_XcmsMatVec((XcmsFloat *) pScreenData->RGBtoXYZmatrix,
+		(XcmsFloat *) &pXcmsColors_in_out->spec, tmp);
+
+	memcpy((char *)&pXcmsColors_in_out->spec, (char *)tmp, sizeof(tmp));
+	(pXcmsColors_in_out++)->format = XcmsCIEXYZFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsRGBiToRGB
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsRGBiToRGB(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColors_in_out,/* pointer to XcmsColors to convert 	*/
+    unsigned int nColors,	/* Number of colors			*/
+    Bool *pCompressed)		/* pointer to a bit array		*/
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from RGBi format to RGB format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded without gamut compression.
+ *		XcmsSuccessWithCompression if succeeded with gamut
+ *			compression.
+ */
+{
+    LINEAR_RGB_SCCData *pScreenData;
+    XcmsRGB tmpRGB;
+    IntensityRec keyIRec, answerIRec;
+
+    /*
+     * pCompressed ignored in this function.
+     */
+
+    if (ccc == NULL) {
+	return(XcmsFailure);
+    }
+
+    pScreenData = (LINEAR_RGB_SCCData *)ccc->pPerScrnInfo->screenData;
+
+    while (nColors--) {
+
+	/* Make sure format is XcmsRGBiFormat */
+	if (pXcmsColors_in_out->format != XcmsRGBiFormat) {
+	    return(XcmsFailure);
+	}
+
+	keyIRec.intensity = pXcmsColors_in_out->spec.RGBi.red;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pRedTbl->pBase,
+		(unsigned)pScreenData->pRedTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsIntensityCmp, (interpolProcp)_XcmsIntensityInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGB.red = answerIRec.value;
+
+	keyIRec.intensity = pXcmsColors_in_out->spec.RGBi.green;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pGreenTbl->pBase,
+		(unsigned)pScreenData->pGreenTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsIntensityCmp, (interpolProcp)_XcmsIntensityInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGB.green = answerIRec.value;
+
+	keyIRec.intensity = pXcmsColors_in_out->spec.RGBi.blue;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pBlueTbl->pBase,
+		(unsigned)pScreenData->pBlueTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsIntensityCmp, (interpolProcp)_XcmsIntensityInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGB.blue = answerIRec.value;
+
+	memcpy((char *)&pXcmsColors_in_out->spec, (char *)&tmpRGB, sizeof(XcmsRGB));
+	(pXcmsColors_in_out++)->format = XcmsRGBFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsRGBToRGBi
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsRGBToRGBi(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColors_in_out,/* pointer to XcmsColors to convert 	*/
+    unsigned int nColors,	/* Number of colors			*/
+    Bool *pCompressed)		/* pointer to a bit array		*/
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from RGB format to RGBi format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ */
+{
+    LINEAR_RGB_SCCData *pScreenData;
+    XcmsRGBi tmpRGBi;
+    IntensityRec keyIRec, answerIRec;
+
+    /*
+     * pCompressed ignored in this function.
+     */
+
+    if (ccc == NULL) {
+	return(XcmsFailure);
+    }
+
+    pScreenData = (LINEAR_RGB_SCCData *)ccc->pPerScrnInfo->screenData;
+
+    while (nColors--) {
+
+	/* Make sure format is XcmsRGBFormat */
+	if (pXcmsColors_in_out->format != XcmsRGBFormat) {
+	    return(XcmsFailure);
+	}
+
+	keyIRec.value = pXcmsColors_in_out->spec.RGB.red;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pRedTbl->pBase,
+		(unsigned)pScreenData->pRedTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsValueCmp, (interpolProcp)_XcmsValueInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGBi.red = answerIRec.intensity;
+
+	keyIRec.value = pXcmsColors_in_out->spec.RGB.green;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pGreenTbl->pBase,
+		(unsigned)pScreenData->pGreenTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsValueCmp, (interpolProcp)_XcmsValueInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGBi.green = answerIRec.intensity;
+
+	keyIRec.value = pXcmsColors_in_out->spec.RGB.blue;
+	if (!_XcmsTableSearch((char *)&keyIRec, ccc->visual->bits_per_rgb,
+		(char *)pScreenData->pBlueTbl->pBase,
+		(unsigned)pScreenData->pBlueTbl->nEntries,
+		(unsigned)sizeof(IntensityRec),
+		(comparProcp)_XcmsValueCmp, (interpolProcp)_XcmsValueInterpolation, (char *)&answerIRec)) {
+	    return(XcmsFailure);
+	}
+	tmpRGBi.blue = answerIRec.intensity;
+
+	memcpy((char *)&pXcmsColors_in_out->spec, (char *)&tmpRGBi, sizeof(XcmsRGBi));
+	(pXcmsColors_in_out++)->format = XcmsRGBiFormat;
+    }
+    return(XcmsSuccess);
+}
+
+/*
+ *	NAME
+ *		_XcmsInitScrnDefaultInfo
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+int
+_XcmsLRGB_InitScrnDefault(
+    Display *dpy,
+    int screenNumber,
+    XcmsPerScrnInfo *pPerScrnInfo)
+/*
+ *	DESCRIPTION
+ *		Given a display and screen number, this routine attempts
+ *		to initialize the Xcms per Screen Info structure
+ *		(XcmsPerScrnInfo) with defaults.
+ *
+ *	RETURNS
+ *		Returns zero if initialization failed; non-zero otherwise.
+ */
+{
+    pPerScrnInfo->screenData = (XPointer)&Default_RGB_SCCData;
+    pPerScrnInfo->screenWhitePt.spec.CIEXYZ.X =
+		Default_RGB_SCCData.RGBtoXYZmatrix[0][0] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[0][1] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[0][2];
+    pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y =
+		Default_RGB_SCCData.RGBtoXYZmatrix[1][0] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[1][1] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[1][2];
+    pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Z =
+		Default_RGB_SCCData.RGBtoXYZmatrix[2][0] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[2][1] +
+		Default_RGB_SCCData.RGBtoXYZmatrix[2][2];
+    if ((pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y < (1.0 - EPS) )
+	    || (pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y > (1.0 + EPS))) {
+	pPerScrnInfo->screenData = (XPointer)NULL;
+	pPerScrnInfo->state = XcmsInitNone;
+	return(0);
+    }
+    pPerScrnInfo->screenWhitePt.spec.CIEXYZ.Y = 1.0;
+    pPerScrnInfo->screenWhitePt.format = XcmsCIEXYZFormat;
+    pPerScrnInfo->screenWhitePt.pixel = 0;
+    pPerScrnInfo->functionSet = (XPointer)&XcmsLinearRGBFunctionSet;
+    pPerScrnInfo->state = XcmsInitFailure; /* default initialization */
+    return(1);
+}
diff --git a/libtinyX11/Lab.c b/libtinyX11/Lab.c
new file mode 100644
index 0000000..02c8d3b
--- /dev/null
+++ b/libtinyX11/Lab.c
@@ -0,0 +1,431 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of XCMS based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *	    CIELab.c
+ *
+ *	DESCRIPTION
+ *		This file contains routines that support the CIE L*a*b*
+ *		color space to include conversions to and from the CIE
+ *		XYZ space.  These conversions are from Principles of
+ *		Color Technology Second Edition, Fred W. Billmeyer, Jr.
+ *		and Max Saltzman, John Wiley & Sons, Inc., 1981.
+ *
+ *		Note that the range for L* is 0 to 1.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xos.h>
+#include <stdio.h> /* sscanf */
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *	DEFINES
+ *		Internal definitions that need NOT be exported to any package
+ *		or program using this package.
+ */
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+#define DIV16BY116	0.137931
+
+/*
+ *	FORWARD DECLARATIONS
+ */
+
+static int CIELab_ParseString(register char *spec, XcmsColor *pColor);
+static Status XcmsCIELab_ValidSpec(XcmsColor *pColor);
+
+
+/*
+ *	LOCAL VARIABLES
+ */
+
+
+    /*
+     * NULL terminated list of functions applied to get from CIELab to CIEXYZ
+     */
+static XcmsConversionProc Fl_CIELab_to_CIEXYZ[] = {
+    XcmsCIELabToCIEXYZ,
+    NULL
+};
+
+    /*
+     * NULL terminated list of functions applied to get from CIEXYZ to CIELab
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_CIELab[] = {
+    XcmsCIEXYZToCIELab,
+    NULL
+};
+
+
+/*
+ *	GLOBALS
+ */
+    /*
+     * CIE Lab Color Space
+     */
+XcmsColorSpace	XcmsCIELabColorSpace =
+    {
+	_XcmsCIELab_prefix,	/* prefix */
+	XcmsCIELabFormat,		/* id */
+	CIELab_ParseString,	/* parseString */
+	Fl_CIELab_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_CIELab,	/* from_CIEXYZ */
+	1
+    };
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIELab_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+CIELab_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsCIELabFormat.
+ *		The assumed CIELab string syntax is:
+ *		    CIELab:<L>/<a>/<b>
+ *		Where L, a, and b are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsCIELab_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.CIELab.L_star,
+	    &pColor->spec.CIELab.a_star,
+	    &pColor->spec.CIELab.b_star) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.CIELab.L_star,
+		       &pColor->spec.CIELab.a_star,
+		       &pColor->spec.CIELab.b_star) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	    return(XcmsFailure);
+    }
+    pColor->format = XcmsCIELabFormat;
+    pColor->pixel = 0;
+
+    return(XcmsCIELab_ValidSpec(pColor));
+}
+
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCIELab_ValidSpec
+ *
+ *	SYNOPSIS
+ */
+static Status
+XcmsCIELab_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if color specification valid for CIE L*a*b*.
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid,
+ *		XcmsSuccess if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsCIELabFormat
+	    ||
+	    (pColor->spec.CIELab.L_star < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIELab.L_star > 100.0 + XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIELabToCIEXYZ - convert CIELab to CIEXYZ
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIELabToCIEXYZ(
+    XcmsCCC ccc,
+    XcmsColor *pLab_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIELab format to CIEXYZ format.
+ *
+ *		WARNING: This routine assumes that Yn = 1.0;
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsCIEXYZ XYZ_return;
+    XcmsFloat tmpFloat, tmpL;
+    XcmsColor whitePt;
+    int i;
+    XcmsColor *pColor = pColors_in_out;
+
+    /*
+     * Check arguments
+     */
+    if (pLab_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEXYZ form, if not, convert it.
+     */
+    if (pLab_WhitePt->format != XcmsCIEXYZFormat) {
+	/* Make a copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pLab_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt,
+		(XcmsColor *)NULL, 1, XcmsCIEXYZFormat)) {
+	    return(XcmsFailure);
+	}
+	pLab_WhitePt = &whitePt;
+    }
+
+    /*
+     * Make sure it is a white point, i.e., Y == 1.0
+     */
+    if (pLab_WhitePt->spec.CIEXYZ.Y != 1.0) {
+	return (0);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is CIELab */
+	if (!XcmsCIELab_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/* Calculate Y: assume that Yn = 1.0 */
+	tmpL = (pColor->spec.CIELab.L_star + 16.0) / 116.0;
+	XYZ_return.Y = tmpL * tmpL * tmpL;
+
+	if (XYZ_return.Y < 0.008856) {
+	    /* Calculate Y: assume that Yn = 1.0 */
+	    tmpL = pColor->spec.CIELab.L_star / 9.03292;
+
+	    /* Calculate X */
+	    XYZ_return.X = pLab_WhitePt->spec.CIEXYZ.X *
+		    ((pColor->spec.CIELab.a_star / 3893.5) + tmpL);
+	    /* Calculate Y */
+	    XYZ_return.Y = tmpL;
+	    /* Calculate Z */
+	    XYZ_return.Z = pLab_WhitePt->spec.CIEXYZ.Z *
+		    (tmpL - (pColor->spec.CIELab.b_star / 1557.4));
+	} else {
+	    /* Calculate X */
+	    tmpFloat = tmpL + (pColor->spec.CIELab.a_star / 5.0);
+	    XYZ_return.X = pLab_WhitePt->spec.CIEXYZ.X * tmpFloat * tmpFloat * tmpFloat;
+
+	    /* Calculate Z */
+	    tmpFloat = tmpL - (pColor->spec.CIELab.b_star / 2.0);
+	    XYZ_return.Z = pLab_WhitePt->spec.CIEXYZ.Z * tmpFloat * tmpFloat * tmpFloat;
+	}
+
+	memcpy((char *)&pColor->spec.CIEXYZ, (char *)&XYZ_return,
+	       sizeof(XcmsCIEXYZ));
+	pColor->format = XcmsCIEXYZFormat;
+    }
+
+    return (1);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEXYZToCIELab - convert CIEXYZ to CIELab
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIEXYZToCIELab(
+    XcmsCCC ccc,
+    XcmsColor *pLab_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIEXYZ format to CIELab format.
+ *
+ *		WARNING: This routine assumes that Yn = 1.0;
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsCIELab Lab_return;
+    XcmsFloat fX_Xn, fY_Yn, fZ_Zn;
+    XcmsColor whitePt;
+    int i;
+    XcmsColor *pColor = pColors_in_out;
+
+    /*
+     * Check arguments
+     */
+    if (pLab_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEXYZ form, if not, convert it.
+     */
+    if (pLab_WhitePt->format != XcmsCIEXYZFormat) {
+	/* Make a copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pLab_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL,
+		1, XcmsCIEXYZFormat)) {
+	    return(XcmsFailure);
+	}
+	pLab_WhitePt = &whitePt;
+    }
+
+    /*
+     * Make sure it is a white point, i.e., Y == 1.0
+     */
+    if (pLab_WhitePt->spec.CIEXYZ.Y != 1.0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is CIELab */
+	if (!_XcmsCIEXYZ_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/* Calculate L*:  assume Yn = 1.0 */
+	if (pColor->spec.CIEXYZ.Y < 0.008856) {
+	    fY_Yn = (0.07787 * pColor->spec.CIEXYZ.Y) + DIV16BY116;
+	    /* note fY_Yn used to compute Lab_return.a below */
+	    Lab_return.L_star = 116.0 * (fY_Yn - DIV16BY116);
+	} else {
+	    fY_Yn = (XcmsFloat)XCMS_CUBEROOT(pColor->spec.CIEXYZ.Y);
+	    /* note fY_Yn used to compute Lab_return.a_star below */
+	    Lab_return.L_star = (116.0 * fY_Yn) - 16.0;
+	}
+
+	/* Calculate f(X/Xn) */
+	if ((fX_Xn = pColor->spec.CIEXYZ.X / pLab_WhitePt->spec.CIEXYZ.X) < 0.008856) {
+	    fX_Xn = (0.07787 * fX_Xn) + DIV16BY116;
+	} else {
+	    fX_Xn = (XcmsFloat) XCMS_CUBEROOT(fX_Xn);
+	}
+
+	/* Calculate f(Z/Zn) */
+	if ((fZ_Zn = pColor->spec.CIEXYZ.Z / pLab_WhitePt->spec.CIEXYZ.Z) < 0.008856) {
+	    fZ_Zn = (0.07787 * fZ_Zn) + DIV16BY116;
+	} else {
+	    fZ_Zn = (XcmsFloat) XCMS_CUBEROOT(fZ_Zn);
+	}
+
+	Lab_return.a_star = 5.0 * (fX_Xn - fY_Yn);
+	Lab_return.b_star = 2.0 * (fY_Yn - fZ_Zn);
+
+	memcpy((char *)&pColor->spec.CIELab, (char *)&Lab_return,
+	       sizeof(XcmsCIELab));
+	pColor->format = XcmsCIELabFormat;
+    }
+
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/LookupCol.c b/libtinyX11/LookupCol.c
index 52732d2..bd8d521 100644
--- a/libtinyX11/LookupCol.c
+++ b/libtinyX11/LookupCol.c
@@ -30,6 +30,9 @@ in this Software without prior written authorization from the X Consortium.
 #include <stdio.h>
 #include "Xlibint.h"
 //#include "Xcmsint.h"
+#ifdef USECMS
+#include <X11/Xcms.h>
+#endif
 
 extern void _XcmsRGB_to_XColor();
 extern void _XUnresolveColor();
diff --git a/libtinyX11/Luv.c b/libtinyX11/Luv.c
new file mode 100644
index 0000000..82bc294
--- /dev/null
+++ b/libtinyX11/Luv.c
@@ -0,0 +1,401 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of XCMS based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		CIELuv.c
+ *
+ *	DESCRIPTION
+ *		This file contains routines that support the CIE L*u*v*
+ *		color space to include conversions to and from the CIE
+ *		XYZ space.
+ *
+ *	DOCUMENTATION
+ *		"TekColor Color Management System, System Implementor's Manual"
+ *		and
+ *		Fred W. Billmeyer & Max Saltzman, "Principles of Color
+ *		Technology", John Wily & Sons, Inc, 1981.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xos.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+#include <stdio.h> /* sscanf */
+
+
+/*
+ *	FORWARD DECLARATIONS
+ */
+
+static int CIELuv_ParseString(register char *spec, XcmsColor *pColor);
+static Status XcmsCIELuv_ValidSpec(XcmsColor *pColor);
+
+/*
+ *	DEFINES
+ *		Internal definitions that need NOT be exported to any package
+ *		or program using this package.
+ */
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+
+
+/*
+ *	LOCAL VARIABLES
+ */
+
+    /*
+     * NULL terminated list of functions applied to get from CIELuv to CIEXYZ
+     */
+static XcmsConversionProc Fl_CIELuv_to_CIEXYZ[] = {
+    XcmsCIELuvToCIEuvY,
+    XcmsCIEuvYToCIEXYZ,
+    NULL
+};
+
+    /*
+     * NULL terminated list of functions applied to get from CIEXYZ to CIELuv
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_CIELuv[] = {
+    XcmsCIEXYZToCIEuvY,
+    XcmsCIEuvYToCIELuv,
+    NULL
+};
+
+/*
+ *	GLOBALS
+ */
+
+    /*
+     * CIE Luv Color Space
+     */
+XcmsColorSpace	XcmsCIELuvColorSpace =
+    {
+	_XcmsCIELuv_prefix,	/* prefix */
+	XcmsCIELuvFormat,		/* id */
+	CIELuv_ParseString,	/* parseString */
+	Fl_CIELuv_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_CIELuv,	/* from_CIEXYZ */
+	1
+    };
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIELuv_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+CIELuv_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsCIELuvFormat.
+ *		The assumed CIELuv string syntax is:
+ *		    CIELuv:<L>/<u>/<v>
+ *		Where L, u, and v are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsCIELuv_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.CIELuv.L_star,
+	    &pColor->spec.CIELuv.u_star,
+	    &pColor->spec.CIELuv.v_star) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.CIELuv.L_star,
+		       &pColor->spec.CIELuv.u_star,
+		       &pColor->spec.CIELuv.v_star) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	return(XcmsFailure);
+    }
+    pColor->format = XcmsCIELuvFormat;
+    pColor->pixel = 0;
+    return(XcmsCIELuv_ValidSpec(pColor));
+}
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCIELuv_ValidSpec
+ *
+ *	SYNOPSIS
+ */
+static Status
+XcmsCIELuv_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if color specification valid for CIE L*u*v*.
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid,
+ *		XcmsSuccess if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsCIELuvFormat
+	    ||
+	    (pColor->spec.CIELuv.L_star < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIELuv.L_star > 100.0 + XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIELuvToCIEuvY - convert CIELuv to CIEuvY
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIELuvToCIEuvY(
+    XcmsCCC ccc,
+    XcmsColor *pLuv_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIELuv format to CIEuvY format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsColor	whitePt;
+    XcmsCIEuvY	uvY_return;
+    XcmsFloat	tmpVal;
+    register int i;
+
+    /*
+     * Check arguments
+     */
+    if (pLuv_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEuvY form
+     */
+    if (pLuv_WhitePt->format != XcmsCIEuvYFormat) {
+	/* Make copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pLuv_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL,
+		1, XcmsCIEuvYFormat)) {
+	    return(XcmsFailure);
+	}
+	pLuv_WhitePt = &whitePt;
+    }
+    /* Make sure it is a white point, i.e., Y == 1.0 */
+    if (pLuv_WhitePt->spec.CIEuvY.Y != 1.0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is CIELuv and is valid */
+	if (!XcmsCIELuv_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	if (pColor->spec.CIELuv.L_star < 7.99953624) {
+	    uvY_return.Y = pColor->spec.CIELuv.L_star / 903.29;
+	} else {
+	    tmpVal = (pColor->spec.CIELuv.L_star + 16.0) / 116.0;
+	    uvY_return.Y = tmpVal * tmpVal * tmpVal; /* tmpVal ** 3 */
+	}
+
+
+
+	if (pColor->spec.CIELuv.L_star == 0.0) {
+	    uvY_return.u_prime = pLuv_WhitePt->spec.CIEuvY.u_prime;
+	    uvY_return.v_prime = pLuv_WhitePt->spec.CIEuvY.v_prime;
+	} else {
+	    tmpVal = 13.0 * (pColor->spec.CIELuv.L_star / 100.0);
+	    uvY_return.u_prime = pColor->spec.CIELuv.u_star/tmpVal +
+			    pLuv_WhitePt->spec.CIEuvY.u_prime;
+	    uvY_return.v_prime = pColor->spec.CIELuv.v_star/tmpVal +
+			    pLuv_WhitePt->spec.CIEuvY.v_prime;
+	}
+	/* Copy result to pColor */
+	memcpy((char *)&pColor->spec, (char *)&uvY_return, sizeof(XcmsCIEuvY));
+
+	/* Identify that the format is now CIEuvY */
+	pColor->format = XcmsCIEuvYFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEuvYToCIELuv - convert CIEuvY to CIELuv
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIEuvYToCIELuv(
+    XcmsCCC ccc,
+    XcmsColor *pLuv_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIEuvY format to CIELab format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsColor	whitePt;
+    XcmsCIELuv	Luv_return;
+    XcmsFloat	tmpVal;
+    register int i;
+
+    /*
+     * Check arguments
+     */
+    if (pLuv_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Make sure white point is in CIEuvY form
+     */
+    if (pLuv_WhitePt->format != XcmsCIEuvYFormat) {
+	/* Make copy of the white point because we're going to modify it */
+	memcpy((char *)&whitePt, (char *)pLuv_WhitePt, sizeof(XcmsColor));
+	if (!_XcmsDIConvertColors(ccc, &whitePt,
+		(XcmsColor *)NULL, 1, XcmsCIEuvYFormat)) {
+	    return(XcmsFailure);
+	}
+	pLuv_WhitePt = &whitePt;
+    }
+    /* Make sure it is a white point, i.e., Y == 1.0 */
+    if (pLuv_WhitePt->spec.CIEuvY.Y != 1.0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	if (!_XcmsCIEuvY_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/* Now convert the uvY to Luv */
+	Luv_return.L_star =
+	    (pColor->spec.CIEuvY.Y < 0.008856)
+	    ?
+	    (pColor->spec.CIEuvY.Y * 903.29)
+	    :
+	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
+	tmpVal = 13.0 * (Luv_return.L_star / 100.0);
+	Luv_return.u_star = tmpVal *
+	   (pColor->spec.CIEuvY.u_prime - pLuv_WhitePt->spec.CIEuvY.u_prime);
+	Luv_return.v_star = tmpVal *
+	   (pColor->spec.CIEuvY.v_prime - pLuv_WhitePt->spec.CIEuvY.v_prime);
+
+	/* Copy result to pColor */
+	memcpy((char *)&pColor->spec, (char *)&Luv_return, sizeof(XcmsCIELuv));
+
+	/* Identify that the format is now CIEuvY */
+	pColor->format = XcmsCIELuvFormat;
+    }
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/Makefile b/libtinyX11/Makefile
index 12bae3b..ddad8a7 100644
--- a/libtinyX11/Makefile
+++ b/libtinyX11/Makefile
@@ -19,8 +19,8 @@ all:	$(OBJS:.c=.o)
 	$(CC) $(LDFLAGS) -o libX11.so.6.2~ -shared -Wl,-soname,libX11.so.6.2 $(OBJS:.c=.o) $(XAUOBJS:.c=.o) \
 	-L../libXext -lXext
 	mv -f libX11.so.6.2~ libX11.so.6.2
-	ln -s libX11.so.6.2 libX11.so.6
-	ln -s libX11.so.6.2 libX11.so
+	ln -sf libX11.so.6.2 libX11.so.6
+	ln -sf libX11.so.6.2 libX11.so
 	
 	@echo "prefix=$(PREDIR)" > x11.pc
 	@echo "exec_prefix=$(PREDIR)/bin" >> x11.pc
diff --git a/libtinyX11/ParseCol.c b/libtinyX11/ParseCol.c
index 5cf2c5d..49b3035 100644
--- a/libtinyX11/ParseCol.c
+++ b/libtinyX11/ParseCol.c
@@ -30,6 +30,9 @@ in this Software without prior written authorization from the X Consortium.
 #include <stdio.h>
 #include "Xlibint.h"
 //#include "Xcmsint.h"
+#ifdef USECMS
+#include <X11/Xcms.h>
+#endif
 
 extern void _XcmsRGB_to_XColor();
 
diff --git a/libtinyX11/QuTextExt.c b/libtinyX11/QuTextExt.c
new file mode 100644
index 0000000..c94c11a
--- /dev/null
+++ b/libtinyX11/QuTextExt.c
@@ -0,0 +1,81 @@
+/*
+
+Copyright 1986, 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+#define NEED_REPLIES
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+
+int
+XQueryTextExtents (
+    register Display *dpy,
+    Font fid,
+    register _Xconst char *string,
+    register int nchars,
+    int *dir,
+    int *font_ascent,
+    int *font_descent,
+    register XCharStruct *overall)
+{
+    register int i;
+    register char *ptr;
+    char *buf;
+    xQueryTextExtentsReply rep;
+    long nbytes;
+    register xQueryTextExtentsReq *req;
+
+    LockDisplay(dpy);
+    nbytes = nchars << 1;
+    GetReq(QueryTextExtents, req);
+    req->fid = fid;
+    if ((buf = _XAllocScratch (dpy, (unsigned long) nbytes))) {
+	req->length += (nbytes + 3)>>2;
+	req->oddLength = nchars & 1;
+	for (ptr = buf, i = nchars; --i >= 0;) {
+	    *ptr++ = 0;
+	    *ptr++ = *string++;
+	}
+	Data (dpy, buf, nbytes);
+    }
+    if (!_XReply (dpy, (xReply *)&rep, 0, xTrue) || !buf) {
+        UnlockDisplay(dpy);
+	SyncHandle();
+	return 0;
+    }
+    *dir = rep.drawDirection;
+    *font_ascent = cvtINT16toInt (rep.fontAscent);
+    *font_descent = cvtINT16toInt (rep.fontDescent);
+    overall->ascent = (short) cvtINT16toShort (rep.overallAscent);
+    overall->descent = (short) cvtINT16toShort (rep.overallDescent);
+    /* XXX bogus - we're throwing away information!!! */
+    overall->width  = (short) cvtINT32toInt (rep.overallWidth);
+    overall->lbearing = (short) cvtINT32toInt (rep.overallLeft);
+    overall->rbearing = (short) cvtINT32toInt (rep.overallRight);
+    UnlockDisplay(dpy);
+    SyncHandle();
+    return 1;
+}
diff --git a/libtinyX11/StNColor.c b/libtinyX11/StNColor.c
index 3582bc5..2ed865f 100644
--- a/libtinyX11/StNColor.c
+++ b/libtinyX11/StNColor.c
@@ -29,6 +29,9 @@ in this Software without prior written authorization from the X Consortium.
 #include <stdio.h>
 #include "Xlibint.h"
 #include "Xcmsint.h"
+#ifdef USECMS
+#include <X11/Xcms.h>
+#endif
 
 extern void _XcmsRGB_to_XColor();
 
diff --git a/libtinyX11/UNDEFINED.c b/libtinyX11/UNDEFINED.c
index 8c9ccbf..56028bc 100644
--- a/libtinyX11/UNDEFINED.c
+++ b/libtinyX11/UNDEFINED.c
@@ -36,6 +36,7 @@
 #ifdef USECMS
 #include "Xlibint.h"
 #include "Xcmsint.h"
+#include <X11/Xcms.h>
 
 /*
  *      FORWARD DECLARATIONS
diff --git a/libtinyX11/XRGB.c b/libtinyX11/XRGB.c
new file mode 100644
index 0000000..03f980e
--- /dev/null
+++ b/libtinyX11/XRGB.c
@@ -0,0 +1,242 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsRtoX.c
+ *
+ *	DESCRIPTION
+ *		Convert color specifications in XcmsRGB format in one array of
+ *		XcmsColor structures to RGB in an array of XColor structures.
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *      LOCAL VARIABLES
+ */
+
+static unsigned short const MASK[17] = {
+    0x0000,	/*  0 bitsPerRGB */
+    0x8000,	/*  1 bitsPerRGB */
+    0xc000,	/*  2 bitsPerRGB */
+    0xe000,	/*  3 bitsPerRGB */
+    0xf000,	/*  4 bitsPerRGB */
+    0xf800,	/*  5 bitsPerRGB */
+    0xfc00,	/*  6 bitsPerRGB */
+    0xfe00,	/*  7 bitsPerRGB */
+    0xff00,	/*  8 bitsPerRGB */
+    0xff80,	/*  9 bitsPerRGB */
+    0xffc0,	/* 10 bitsPerRGB */
+    0xffe0,	/* 11 bitsPerRGB */
+    0xfff0,	/* 12 bitsPerRGB */
+    0xfff8,	/* 13 bitsPerRGB */
+    0xfffc,	/* 14 bitsPerRGB */
+    0xfffe,	/* 15 bitsPerRGB */
+    0xffff	/* 16 bitsPerRGB */
+};
+
+
+
+/************************************************************************
+ *									*
+ *			API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsRGB_to_XColor -
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsRGB_to_XColor(
+    XcmsColor *pColors,
+    XColor *pXColors,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *	    Translates a color specification in XcmsRGBFormat in a XcmsColor
+ * 	    structure to an XColor structure.
+ *
+ *	RETURNS
+ *		void.
+ */
+{
+    for (; nColors--; pXColors++, pColors++) {
+	pXColors->pixel = pColors->pixel;
+	pXColors->red = pColors->spec.RGB.red;
+	pXColors->green = pColors->spec.RGB.green;
+	pXColors->blue  = pColors->spec.RGB.blue;
+	pXColors->flags = (DoRed | DoGreen | DoBlue);
+    }
+}
+
+
+/*
+ *	NAME
+ *		_XColor_to_XcmsRGB
+ *
+ *	SYNOPSIS
+ */
+void
+_XColor_to_XcmsRGB(
+    XcmsCCC ccc,
+    XColor *pXColors,
+    XcmsColor *pColors,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Translates an RGB color specification in an XColor
+ *		structure to an XcmsRGB structure.
+ *
+ *		IMPORTANT NOTE:  Bit replication that may have been caused
+ *		with ResolveColor() routine in the X Server is undone
+ *		here if requested!  For example, if red = 0xcaca and the
+ *		bits_per_rgb is 8, then spec.RGB.red will be 0xca00.
+ *
+ *	RETURNS
+ *		void
+ */
+{
+    int bits_per_rgb = ccc->visual->bits_per_rgb;
+
+    for (; nColors--; pXColors++, pColors++) {
+	pColors->spec.RGB.red = (pXColors->red & MASK[bits_per_rgb]);
+	pColors->spec.RGB.green = (pXColors->green & MASK[bits_per_rgb]);
+	pColors->spec.RGB.blue = (pXColors->blue & MASK[bits_per_rgb]);
+	pColors->format = XcmsRGBFormat;
+	pColors->pixel = pXColors->pixel;
+    }
+}
+
+
+/*
+ *	NAME
+ *		_XcmsResolveColor
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsResolveColor(
+    XcmsCCC ccc,
+    XcmsColor *pXcmsColor)
+/*
+ *	DESCRIPTION
+ *	    Uses the X Server ResolveColor() algorithm to
+ *	    modify values to closest values supported by hardware.
+ *	    Old algorithm simply masked low-order bits.  The new algorithm
+ *	    has the effect of replicating significant bits into lower order
+ *	    bits in order to stretch the hardware value into all 16 bits.
+ *
+ *	    On a display with N-bit DACs, the "hardware" color is computed as:
+ *
+ *	    ((unsignedlong)(ClientValue >> (16-N)) * 0xFFFF) / ((1 << N) - 1)
+ *
+ *
+ *	RETURNS
+ *		void.
+ */
+{
+    int shift;
+    int max_color;
+
+    shift = 16 - ccc->visual->bits_per_rgb;
+    max_color = (1 << ccc->visual->bits_per_rgb) - 1;
+
+
+    pXcmsColor->spec.RGB.red =
+	    ((unsigned long)(pXcmsColor->spec.RGB.red >> shift) * 0xFFFF)
+	    / max_color;
+    pXcmsColor->spec.RGB.green =
+	    ((unsigned long)(pXcmsColor->spec.RGB.green >> shift) * 0xFFFF)
+	    / max_color;
+    pXcmsColor->spec.RGB.blue =
+	    ((unsigned long)(pXcmsColor->spec.RGB.blue  >> shift) * 0xFFFF)
+	    / max_color;
+}
+
+
+/*
+ *	NAME
+ *		_XcmsUnresolveColor
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsUnresolveColor(
+    XcmsCCC ccc,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Masks out insignificant bits.
+ *
+ *	RETURNS
+ *		void.
+ *
+ *	ASSUMPTIONS
+ *		format == XcmsRGBFormat
+ */
+{
+    int bits_per_rgb = ccc->visual->bits_per_rgb;
+
+    pColor->spec.RGB.red &= MASK[bits_per_rgb];
+    pColor->spec.RGB.green &= MASK[bits_per_rgb];
+    pColor->spec.RGB.blue &= MASK[bits_per_rgb];
+}
+
+
+/*
+ *	NAME
+ *		_XUnresolveColor
+ *
+ *	SYNOPSIS
+ */
+void
+_XUnresolveColor(
+    XcmsCCC ccc,
+    XColor *pXColor)
+/*
+ *	DESCRIPTION
+ *		Masks out insignificant bits.
+ *
+ *	RETURNS
+ *		void.
+ */
+{
+    int bits_per_rgb = ccc->visual->bits_per_rgb;
+
+    pXColor->red &= MASK[bits_per_rgb];
+    pXColor->green &= MASK[bits_per_rgb];
+    pXColor->blue &= MASK[bits_per_rgb];
+}
+
diff --git a/libtinyX11/XYZ.c b/libtinyX11/XYZ.c
new file mode 100644
index 0000000..40d6ed3
--- /dev/null
+++ b/libtinyX11/XYZ.c
@@ -0,0 +1,203 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of XCMS based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *
+ *	NAME
+ *		CIEXYZ.c
+ *
+ *	DESCRIPTION
+ *		CIE XYZ Color Space
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xos.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+#include <stdio.h> /* sscanf */
+
+/*
+ *	DEFINES
+ *		Internal definitions that need NOT be exported to any package
+ *		or program using this package.
+ */
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+
+/*
+ *      FORWARD DECLARATIONS
+ */
+static int CIEXYZ_ParseString(register char *spec, XcmsColor *pColor);
+
+/*
+ *      LOCALS VARIABLES
+ */
+
+static XcmsConversionProc Fl_CIEXYZ_to_CIEXYZ[] = {
+    NULL
+};
+
+
+
+/*
+ *      GLOBALS
+ *              Variables declared in this package that are allowed
+ *		to be used globally.
+ */
+    /*
+     * CIE XYZ Color Space
+     */
+XcmsColorSpace	XcmsCIEXYZColorSpace =
+    {
+	_XcmsCIEXYZ_prefix,		/* prefix */
+	XcmsCIEXYZFormat,		/* id */
+	CIEXYZ_ParseString,	/* parseString */
+	Fl_CIEXYZ_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_CIEXYZ,	/* from_CIEXYZ */
+	1
+    };
+
+
+/************************************************************************
+ *									*
+ *			PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIEXYZ_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+CIEXYZ_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsCIEXYZFormat.
+ *		The assumed CIEXYZ string syntax is:
+ *		    CIEXYZ:<X>/<Y>/<Z>
+ *		Where X, Y, and Z are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsCIEXYZ_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.CIEXYZ.X,
+	    &pColor->spec.CIEXYZ.Y,
+	    &pColor->spec.CIEXYZ.Z) != 3) {
+	char *s; /* Maybe failed due to locale */
+	int f;
+	if ((s = strdup(spec))) {
+	    for (f = 0; s[f]; ++f)
+		if (s[f] == '.')
+		    s[f] = ',';
+		else if (s[f] == ',')
+		    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.CIEXYZ.X,
+		       &pColor->spec.CIEXYZ.Y,
+		       &pColor->spec.CIEXYZ.Z) != 3) {
+		free(s);
+		return(XcmsFailure);
+	    }
+	    free(s);
+	} else
+	    return(XcmsFailure);
+    }
+    pColor->format = XcmsCIEXYZFormat;
+    pColor->pixel = 0;
+    return(_XcmsCIEXYZ_ValidSpec(pColor));
+}
+
+
+/************************************************************************
+ *									*
+ *			PUBLIC ROUTINES 				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCIELab_ValidSpec
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsCIEXYZ_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if color specification valid for CIE XYZ
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid,
+ *		XcmsSuccess if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsCIEXYZFormat
+	    ||
+	    (pColor->spec.CIEXYZ.Y < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIEXYZ.Y > 1.0 + XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/Xcmsint.h b/libtinyX11/Xcmsint.h
index e69de29..2c8071c 100644
--- a/libtinyX11/Xcmsint.h
+++ b/libtinyX11/Xcmsint.h
@@ -0,0 +1,260 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	DESCRIPTION
+ *		Private include file for Color Management System.
+ *		(i.e., for API internal use only)
+ *
+ */
+
+#ifndef _XCMSINT_H_
+#define _XCMSINT_H_
+
+#include <X11/Xcms.h>
+
+/*
+ *	DEFINES
+ */
+
+	/*
+	 * Private Status Value
+	 */
+#define	_XCMS_NEWNAME	-1
+
+	/*
+	 * Color Space ID's are of XcmsColorFormat type.
+	 *
+	 *	bit 31
+	 *	    0 == Device-Independent
+	 *	    1 == Device-Dependent
+	 *
+	 *	bit 30:
+         *          0 == Registered with X Consortium
+         *          1 == Unregistered
+         */
+#define       XCMS_DD_ID(id)          ((id) & (XcmsColorFormat)0x80000000)
+#define       XCMS_DI_ID(id)          (!((id) & (XcmsColorFormat)0x80000000))
+#define       XCMS_UNREG_ID(id)       ((id) & (XcmsColorFormat)0x40000000)
+#define       XCMS_REG_ID(id)         (!((id) & (XcmsColorFormat)0x40000000))
+#define       XCMS_FIRST_REG_DI_ID    (XcmsColorFormat)0x00000001
+#define       XCMS_FIRST_UNREG_DI_ID  (XcmsColorFormat)0x40000000
+#define       XCMS_FIRST_REG_DD_ID    (XcmsColorFormat)0x80000000
+#define       XCMS_FIRST_UNREG_DD_ID  (XcmsColorFormat)0xc0000000
+
+/*
+ *	TYPEDEFS
+ */
+
+    /*
+     * Structure for caching Colormap info.
+     *    This is provided for the Xlib modifications to:
+     *		XAllocNamedColor()
+     *		XLookupColor()
+     *		XParseColor()
+     *		XStoreNamedColor()
+     */
+typedef struct _XcmsCmapRec {
+    Colormap cmapID;
+    Display *dpy;
+    Window windowID;
+    Visual *visual;
+    struct _XcmsCCC *ccc;
+    struct _XcmsCmapRec *pNext;
+} XcmsCmapRec;
+
+    /*
+     * Intensity Record (i.e., value / intensity tuple)
+     */
+typedef struct _IntensityRec {
+    unsigned short value;
+    XcmsFloat intensity;
+} IntensityRec;
+
+    /*
+     * Intensity Table
+     */
+typedef struct _IntensityTbl {
+    IntensityRec *pBase;
+    unsigned int nEntries;
+} IntensityTbl;
+
+    /*
+     * Structure for storing per-Visual Intensity Tables (aka gamma maps).
+     */
+typedef struct _XcmsIntensityMap {
+    VisualID visualID;
+    XPointer	screenData;	/* pointer to corresponding Screen Color*/
+				/*	Characterization Data		*/
+    void (*pFreeScreenData)(XPointer pScreenDataTemp);	/* Function that frees a Screen		*/
+				/*   structure.				*/
+    struct _XcmsIntensityMap *pNext;
+} XcmsIntensityMap;
+
+
+    /*
+     * Structure for storing "registered" color space prefix/ID
+     */
+typedef struct _XcmsRegColorSpaceEntry {
+    const char *prefix;	/* Color Space prefix (e.g., "CIEXYZ:") */
+    XcmsColorFormat id;	/* Color Space ID (e.g., XcmsCIEXYZFormat) */
+} XcmsRegColorSpaceEntry;
+
+
+    /*
+     * Xcms Per Display (i.e. connection) related data
+     */
+typedef struct _XcmsPerDpyInfo {
+
+    XcmsCCC paDefaultCCC; /* based on default visual of screen */
+	    /*
+	     * Pointer to an array of XcmsCCC structures, one for
+	     * each screen.
+	     */
+    XcmsCmapRec *pClientCmaps;	/* Pointer to linked list of XcmsCmapRec's */
+
+} XcmsPerDpyInfo, *XcmsPerDpyInfoPtr;
+
+/*
+ *	DEFINES
+ */
+
+#define XDCCC_NUMBER	0x8000000L	/* 2**27 per XDCCC */
+
+#ifdef GRAY
+#define XDCCC_SCREENWHITEPT_ATOM_NAME	"XDCCC_GRAY_SCREENWHITEPOINT"
+#define XDCCC_GRAY_CORRECT_ATOM_NAME	"XDCCC_GRAY_CORRECTION"
+#endif /* GRAY */
+
+#ifndef _ConversionValues
+typedef struct _ConversionValues {
+    IntensityTbl IntensityTbl;
+} ConversionValues;
+#endif
+
+#ifdef GRAY
+typedef struct {
+    IntensityTbl *IntensityTbl;
+} GRAY_SCCData;
+#endif /* GRAY */
+
+/*
+ *	DEFINES
+ */
+
+#define XDCCC_MATRIX_ATOM_NAME	"XDCCC_LINEAR_RGB_MATRICES"
+#define XDCCC_CORRECT_ATOM_NAME "XDCCC_LINEAR_RGB_CORRECTION"
+
+typedef struct {
+    XcmsFloat XYZtoRGBmatrix[3][3];
+    XcmsFloat RGBtoXYZmatrix[3][3];
+    IntensityTbl *pRedTbl;
+    IntensityTbl *pGreenTbl;
+    IntensityTbl *pBlueTbl;
+} LINEAR_RGB_SCCData;
+
+/* function prototypes */
+extern XcmsCmapRec *
+_XcmsAddCmapRec(
+    Display *dpy,
+    Colormap cmap,
+    Window windowID,
+    Visual *visual);
+extern void
+_XcmsRGB_to_XColor(
+    XcmsColor *pColors,
+    XColor *pXColors,
+    unsigned int nColors);
+extern Status
+_XcmsResolveColorString (
+    XcmsCCC ccc,
+    const char **color_string,
+    XcmsColor *pColor_exact_return,
+    XcmsColorFormat result_format);
+extern void
+_XUnresolveColor(
+    XcmsCCC ccc,
+    XColor *pXColor);
+/*
+ *	DESCRIPTION
+ *		Include file for defining the math macros used in the
+ *		XCMS source.  Instead of using math library routines
+ *		directly, XCMS uses macros so that based on the
+ *		definitions here, vendors and sites can specify exactly
+ *		what routine will be called (those from libm.a or their
+ *		custom routines).  If not defined to math library routines
+ *		(e.g., sqrt in libm.a), then the client is not forced to
+ *		be linked with -lm.
+ */
+
+#define XCMS_ATAN(x)		atan(x)
+#define XCMS_COS(x)		cos(x)
+#define XCMS_CUBEROOT(x)	cbrt(x)
+#define XCMS_FABS(x)		((x) < 0.0 ? -(x) : (x))
+#define XCMS_SIN(x)		sin(x)
+#define XCMS_SQRT(x)		sqrt(x)
+#define XCMS_TAN(x)		(XCMS_SIN(x) / XCMS_COS(x))
+
+double _XcmsArcTangent(double a);
+double _XcmsCosine(double a);
+double _XcmsCubeRoot(double a);
+double _XcmsSine(double a);
+double _XcmsSquareRoot(double a);
+
+/*
+ *  DEFINES FOR GAMUT COMPRESSION AND QUERY ROUTINES
+ */
+#ifndef PI
+#  ifdef M_PI
+#    define PI M_PI
+#  else
+#    define PI 3.14159265358979323846264338327950
+#  endif /* M_PI */
+#endif /* PI */
+#ifndef degrees
+#  define degrees(r) ((XcmsFloat)(r) * 180.0 / PI)
+#endif /* degrees */
+#ifndef radians
+#  define radians(d) ((XcmsFloat)(d) * PI / 180.0)
+#endif /* radians */
+
+#define XCMS_CIEUSTAROFHUE(h,c)	\
+((XCMS_COS((h)) == 0.0) ? (XcmsFloat)0.0 : (XcmsFloat) \
+((XcmsFloat)(c) / (XcmsFloat)XCMS_SQRT((XCMS_TAN(h) * XCMS_TAN(h)) + \
+(XcmsFloat)1.0)))
+#define XCMS_CIEVSTAROFHUE(h,c)	\
+((XCMS_COS((h)) == 0.0) ? (XcmsFloat)0.0 : (XcmsFloat) \
+((XcmsFloat)(c) / (XcmsFloat)XCMS_SQRT(((XcmsFloat)1.0 / \
+(XcmsFloat)(XCMS_TAN(h) * XCMS_TAN(h))) + (XcmsFloat)1.0)))
+/* this hue is returned in radians */
+#define XCMS_CIELUV_PMETRIC_HUE(u,v)	\
+(((u) != 0.0) ? XCMS_ATAN( (v) / (u)) : ((v >= 0.0) ? PI / 2 : -(PI / 2)))
+#define XCMS_CIELUV_PMETRIC_CHROMA(u,v)	XCMS_SQRT(((u)*(u)) + ((v)*(v)))
+
+#define XCMS_CIEASTAROFHUE(h,c)		XCMS_CIEUSTAROFHUE((h), (c))
+#define XCMS_CIEBSTAROFHUE(h,c)		XCMS_CIEVSTAROFHUE((h), (c))
+#define XCMS_CIELAB_PMETRIC_HUE(a,b)	XCMS_CIELUV_PMETRIC_HUE((a), (b))
+#define XCMS_CIELAB_PMETRIC_CHROMA(a,b)	XCMS_CIELUV_PMETRIC_CHROMA((a), (b))
+
+#endif /* _XCMSINT_H_ */
diff --git a/libtinyX11/cmsCmap.c b/libtinyX11/cmsCmap.c
new file mode 100644
index 0000000..f93a25b
--- /dev/null
+++ b/libtinyX11/cmsCmap.c
@@ -0,0 +1,495 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsCmap.c - Client Colormap Management Routines
+ *
+ *	DESCRIPTION
+ *		Routines that store additional information about
+ *		colormaps being used by the X Client.
+ *
+ *
+ */
+
+#define NEED_EVENTS
+#define NEED_REPLIES
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Xutil.h"
+#include "Cmap.h"
+#include "Cv.h"
+
+/*
+ *      FORWARD DECLARATIONS
+ */
+static void _XcmsFreeClientCmaps(Display *dpy);
+
+
+/************************************************************************
+ *									*
+ *			PRIVATE INTERFACES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CmapRecForColormap
+ *
+ *	SYNOPSIS
+ */
+static XcmsCmapRec *
+CmapRecForColormap(
+    Display *dpy,
+    Colormap cmap)
+/*
+ *	DESCRIPTION
+ *		Find the corresponding XcmsCmapRec for cmap.  In not found
+ *		this routines attempts to create one.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the corresponding XcmsCmapRec.
+ *
+ */
+{
+    XcmsCmapRec *pRec;
+    int nScrn;
+    int i, j;
+    XVisualInfo visualTemplate;	/* Template of the visual we want */
+    XVisualInfo *visualList;	/* List for visuals that match */
+    int nVisualsMatched;	/* Number of visuals that match */
+    Window tmpWindow;
+    Visual *vp;
+    unsigned long border = 0;
+    _XAsyncHandler async;
+    _XAsyncErrorState async_state;
+
+    for (pRec = (XcmsCmapRec *)dpy->cms.clientCmaps; pRec != NULL;
+	    pRec = pRec->pNext) {
+	if (pRec->cmapID == cmap) {
+	    return(pRec);
+	}
+    }
+
+    /*
+     * Can't find an XcmsCmapRec associated with cmap in our records.
+     * Let's try to see if its a default colormap
+     */
+    nScrn = ScreenCount(dpy);
+    for (i = 0; i < nScrn; i++) {
+	if (cmap == DefaultColormap(dpy, i)) {
+	    /* It is ... lets go ahead and store that info */
+	    if ((pRec = _XcmsAddCmapRec(dpy, cmap, RootWindow(dpy, i),
+		    DefaultVisual(dpy, i))) == NULL) {
+		return((XcmsCmapRec *)NULL);
+	    }
+	    pRec->ccc = XcmsCreateCCC(
+		    dpy,
+		    i,			/* screenNumber */
+		    DefaultVisual(dpy, i),
+		    (XcmsColor *)NULL,	/* clientWhitePt */
+		    (XcmsCompressionProc)NULL,  /* gamutCompProc */
+		    (XPointer)NULL,	/* gamutCompClientData */
+		    (XcmsWhiteAdjustProc)NULL,  /* whitePtAdjProc */
+		    (XPointer)NULL	/* whitePtAdjClientData */
+		    );
+	    return(pRec);
+	}
+    }
+
+    /*
+     * Nope, its not a default colormap, so it's probably a foreign color map
+     * of which we have no specific details.  Let's go through the
+     * rigorous process of finding this colormap:
+     *        for each screen
+     *            for each screen's visual types
+     *                create a window with cmap specified as the colormap
+     *                if successful
+     *                    Add a CmapRec
+     *                    Create an XcmsCCC
+     *                    return the CmapRec
+     *                else
+     *                    continue
+     */
+
+    async_state.error_code = 0; /* don't care */
+    async_state.major_opcode = X_CreateWindow;
+    async_state.minor_opcode = 0;
+    for (i = 0; i < nScrn; i++) {
+	visualTemplate.screen = i;
+	visualList = XGetVisualInfo(dpy, VisualScreenMask, &visualTemplate,
+	    &nVisualsMatched);
+	if (visualList == NULL) {
+	    continue;
+	}
+
+	/*
+	 * Attempt to create a window with cmap
+	 */
+	j = 0;
+	do {
+	    vp = (visualList+j)->visual;
+	    LockDisplay(dpy);
+	    {
+		register xCreateWindowReq *req;
+
+		GetReq(CreateWindow, req);
+		async_state.min_sequence_number = dpy->request;
+		async_state.max_sequence_number = dpy->request;
+		async_state.error_count = 0;
+		async.next = dpy->async_handlers;
+		async.handler = _XAsyncErrorHandler;
+		async.data = (XPointer)&async_state;
+		dpy->async_handlers = &async;
+		req->parent = RootWindow(dpy, i);
+		req->x = 0;
+		req->y = 0;
+		req->width = 1;
+		req->height = 1;
+		req->borderWidth = 0;
+		req->depth = (visualList+j)->depth;
+		req->class = CopyFromParent;
+		req->visual = vp->visualid;
+		tmpWindow = req->wid = XAllocID(dpy);
+		req->mask = CWBorderPixel | CWColormap;
+		req->length += 2;
+		Data32 (dpy, (long *) &border, 4);
+		Data32 (dpy, (long *) &cmap, 4);
+	    }
+	    {
+		xGetInputFocusReply rep;
+		register xReq *req;
+
+		GetEmptyReq(GetInputFocus, req);
+		(void) _XReply (dpy, (xReply *)&rep, 0, xTrue);
+	    }
+	    DeqAsyncHandler(dpy, &async);
+	    UnlockDisplay(dpy);
+	    SyncHandle();
+	} while (async_state.error_count > 0 && ++j < nVisualsMatched);
+
+	Xfree((char *)visualList);
+
+	/*
+	 * if successful
+	 */
+	if (j < nVisualsMatched) {
+	    if ((pRec = _XcmsAddCmapRec(dpy, cmap, tmpWindow, vp)) == NULL)
+		return((XcmsCmapRec *)NULL);
+	    pRec->ccc = XcmsCreateCCC(
+		    dpy,
+		    i,			/* screenNumber */
+		    vp,
+		    (XcmsColor *)NULL,	/* clientWhitePt */
+		    (XcmsCompressionProc)NULL,  /* gamutCompProc */
+		    (XPointer)NULL,	/* gamutCompClientData */
+		    (XcmsWhiteAdjustProc)NULL,  /* whitePtAdjProc */
+		    (XPointer)NULL	/* whitePtAdjClientData */
+		    );
+	    XDestroyWindow(dpy, tmpWindow);
+	    return(pRec);
+	}
+    }
+
+    return(NULL);
+}
+
+
+
+/************************************************************************
+ *									*
+ *			API PRIVATE INTERFACES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsAddCmapRec
+ *
+ *	SYNOPSIS
+ */
+XcmsCmapRec *
+_XcmsAddCmapRec(
+    Display *dpy,
+    Colormap cmap,
+    Window windowID,
+    Visual *visual)
+/*
+ *	DESCRIPTION
+ *		Create an XcmsCmapRec for the specified cmap, windowID,
+ *		and visual, then adds it to its list of CmapRec's.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the added XcmsCmapRec.
+ *
+ */
+{
+    XcmsCmapRec *pNew;
+
+    if ((pNew = (XcmsCmapRec *) Xcalloc(1, (unsigned) sizeof(XcmsCmapRec)))
+	    == NULL) {
+	return((XcmsCmapRec *)NULL);
+    }
+
+    pNew->cmapID = cmap;
+    pNew->dpy = dpy;
+    pNew->windowID = windowID;
+    pNew->visual = visual;
+    pNew->pNext = (XcmsCmapRec *)dpy->cms.clientCmaps;
+    dpy->cms.clientCmaps = (XPointer)pNew;
+    dpy->free_funcs->clientCmaps = _XcmsFreeClientCmaps;
+
+    /*
+     * Note, we don't create the XcmsCCC for pNew->ccc here because
+     * it may require the use of XGetWindowAttributes (a round trip request)
+     * to determine the screen.
+     */
+    return(pNew);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsCopyCmapRecAndFree
+ *
+ *	SYNOPSIS
+ */
+XcmsCmapRec *
+_XcmsCopyCmapRecAndFree(
+    Display *dpy,
+    Colormap src_cmap,
+    Colormap copy_cmap)
+/*
+ *	DESCRIPTION
+ *		Augments Xlib's XCopyColormapAndFree() to copy
+ *		XcmsCmapRecs.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the copy XcmsCmapRec.
+ *
+ */
+{
+    XcmsCmapRec *pRec_src;
+    XcmsCmapRec *pRec_copy;
+
+    if ((pRec_src = CmapRecForColormap(dpy, src_cmap)) != NULL) {
+	pRec_copy =_XcmsAddCmapRec(dpy, copy_cmap, pRec_src->windowID,
+		pRec_src->visual);
+	if (pRec_copy != NULL && pRec_src->ccc) {
+	    pRec_copy->ccc = (XcmsCCC)Xcalloc(1, (unsigned) sizeof(XcmsCCCRec));
+	    memcpy((char *)pRec_copy->ccc, (char *)pRec_src->ccc,
+		   sizeof(XcmsCCCRec));
+	}
+	return(pRec_copy);
+    }
+    return((XcmsCmapRec *)NULL);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsDeleteCmapRec
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsDeleteCmapRec(
+    Display *dpy,
+    Colormap cmap)
+/*
+ *	DESCRIPTION
+ *		Removes and frees the specified XcmsCmapRec structure
+ *		from the linked list of structures.
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    XcmsCmapRec **pPrevPtr;
+    XcmsCmapRec *pRec;
+    int scr;
+
+    /* If it is the default cmap for a screen, do not delete it,
+     * because the server will not actually free it */
+    for (scr = ScreenCount(dpy); --scr >= 0; ) {
+	if (cmap == DefaultColormap(dpy, scr))
+	    return;
+    }
+
+    /* search for it in the list */
+    pPrevPtr = (XcmsCmapRec **)&dpy->cms.clientCmaps;
+    while ((pRec = *pPrevPtr) && (pRec->cmapID != cmap)) {
+	pPrevPtr = &pRec->pNext;
+    }
+
+    if (pRec) {
+	if (pRec->ccc) {
+	    XcmsFreeCCC(pRec->ccc);
+	}
+	*pPrevPtr = pRec->pNext;
+	Xfree((char *)pRec);
+    }
+}
+
+
+/*
+ *	NAME
+ *		_XcmsFreeClientCmaps
+ *
+ *	SYNOPSIS
+ */
+static void
+_XcmsFreeClientCmaps(
+    Display *dpy)
+/*
+ *	DESCRIPTION
+ *		Frees all XcmsCmapRec structures in the linked list
+ *		and sets dpy->cms.clientCmaps to NULL.
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    XcmsCmapRec *pRecNext, *pRecFree;
+
+    pRecNext = (XcmsCmapRec *)dpy->cms.clientCmaps;
+    while (pRecNext != NULL) {
+	pRecFree = pRecNext;
+	pRecNext = pRecNext->pNext;
+	if (pRecFree->ccc) {
+	    /* Free the XcmsCCC structure */
+	    XcmsFreeCCC(pRecFree->ccc);
+	}
+	/* Now free the XcmsCmapRec structure */
+	Xfree((char *)pRecFree);
+    }
+    dpy->cms.clientCmaps = (XPointer)NULL;
+}
+
+
+
+/************************************************************************
+ *									*
+ *			PUBLIC INTERFACES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCCCOfColormap
+ *
+ *	SYNOPSIS
+ */
+XcmsCCC
+XcmsCCCOfColormap(
+    Display *dpy,
+    Colormap cmap)
+/*
+ *	DESCRIPTION
+ *		Finds the XcmsCCC associated with the specified colormap.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the associated XcmsCCC structure.
+ *
+ */
+{
+    XWindowAttributes windowAttr;
+    XcmsCmapRec *pRec;
+    int nScrn = ScreenCount(dpy);
+    int i;
+
+    if ((pRec = CmapRecForColormap(dpy, cmap)) != NULL) {
+	if (pRec->ccc) {
+	    /* XcmsCmapRec already has a XcmsCCC */
+	    return(pRec->ccc);
+	}
+
+	/*
+	 * The XcmsCmapRec does not have a XcmsCCC yet, so let's create
+	 * one.  But first, we need to know the screen associated with
+	 * cmap, so use XGetWindowAttributes() to extract that
+	 * information.  Unless, of course there is only one screen!!
+	 */
+	if (nScrn == 1) {
+	    /* Assume screenNumber == 0 */
+	    return(pRec->ccc = XcmsCreateCCC(
+		    dpy,
+		    0,			/* screenNumber */
+		    pRec->visual,
+		    (XcmsColor *)NULL,	/* clientWhitePt */
+		    (XcmsCompressionProc)NULL,  /* gamutCompProc */
+		    (XPointer)NULL,	/* gamutCompClientData */
+		    (XcmsWhiteAdjustProc)NULL,  /* whitePtAdjProc */
+		    (XPointer)NULL	/* whitePtAdjClientData */
+		    ));
+	} else {
+	    if (XGetWindowAttributes(dpy, pRec->windowID, &windowAttr)) {
+		for (i = 0; i < nScrn; i++) {
+		    if (ScreenOfDisplay(dpy, i) == windowAttr.screen) {
+			return(pRec->ccc = XcmsCreateCCC(
+				dpy,
+				i,		   /* screenNumber */
+				pRec->visual,
+				(XcmsColor *)NULL, /* clientWhitePt */
+				(XcmsCompressionProc)NULL, /* gamutCompProc */
+				(XPointer)NULL,	   /* gamutCompClientData */
+				(XcmsWhiteAdjustProc)NULL, /* whitePtAdjProc */
+				(XPointer)NULL	   /* whitePtAdjClientData */
+				));
+		    }
+		}
+	    }
+	}
+    }
+
+    /*
+     * No such cmap
+     */
+    return(NULL);
+}
+
+XcmsCCC XcmsSetCCCOfColormap(
+    Display *dpy,
+    Colormap cmap,
+    XcmsCCC ccc)
+{
+    XcmsCCC prev_ccc = NULL;
+    XcmsCmapRec *pRec;
+
+    pRec = CmapRecForColormap(dpy, cmap);
+    if (pRec) {
+	prev_ccc = pRec->ccc;
+	pRec->ccc = ccc;
+    }
+    return prev_ccc;
+}
diff --git a/libtinyX11/cmsColNm.c b/libtinyX11/cmsColNm.c
new file mode 100644
index 0000000..f32b6d3
--- /dev/null
+++ b/libtinyX11/cmsColNm.c
@@ -0,0 +1,1039 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		XcmsColNm.c
+ *
+ *	DESCRIPTION
+ *		Source for _XcmsLookupColorName().
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include <X11/Xos.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <ctype.h>
+#define XK_LATIN1
+#include <X11/keysymdef.h>
+#include "Cv.h"
+
+/* forwards/locals */
+static Status LoadColornameDB(void);
+
+
+/*
+ *      LOCAL DEFINES
+ *		#define declarations local to this package.
+ */
+#ifndef XCMSDB
+#define XCMSDB  "/usr/lib/X11/Xcms.txt"
+#endif
+
+#ifndef isgraph
+#  define isgraph(c)	(isprint((c)) && !isspace((c)))
+#endif
+
+#ifndef XCMSDB_MAXLINELEN
+#  define XCMSDB_MAXLINELEN	256
+#endif
+
+#define FORMAT_VERSION	"0.1"
+#define START_TOKEN	"XCMS_COLORDB_START"
+#define END_TOKEN	"XCMS_COLORDB_END"
+#define DELIM_CHAR	'\t'
+
+#define	NOT_VISITED	0x0
+#define	VISITED		0x1
+#define CYCLE		0xFFFF
+#define XcmsDbInitNone		-1
+#define XcmsDbInitFailure	0
+#define XcmsDbInitSuccess	1
+
+/*
+ *      LOCAL TYPEDEFS
+ */
+typedef struct _XcmsPair {
+    const char *first;
+    const char *second;
+    int flag;
+} XcmsPair;
+
+/*
+ *      LOCAL VARIABLES
+ */
+static int XcmsColorDbState = XcmsDbInitNone;
+static int nEntries;
+static char *strings;
+static XcmsPair *pairs;
+static const char whitePtStr[] = "WhitePoint";
+
+
+/************************************************************************
+ *									*
+ *			PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsColorSpaceOfString
+ *
+ *	SYNOPSIS
+ */
+static XcmsColorSpace *
+_XcmsColorSpaceOfString(
+    XcmsCCC ccc,
+    const char *color_string)
+/*
+ *	DESCRIPTION
+ *		Returns a pointer to the color space structure
+ *		(XcmsColorSpace) associated with the specified color string.
+ *
+ *	RETURNS
+ *		Pointer to matching XcmsColorSpace structure if found;
+ *		otherwise NULL.
+ *
+ *	CAVEATS
+ *
+ */
+{
+    XcmsColorSpace	**papColorSpaces;
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(color_string, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - color_string);
+
+    if (ccc == NULL) {
+	return(NULL);
+    }
+
+    /*
+     * First try Device-Independent color spaces
+     */
+    papColorSpaces = _XcmsDIColorSpaces;
+    if (papColorSpaces != NULL) {
+	while (*papColorSpaces != NULL) {
+	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0 &&
+		!((*papColorSpaces)->prefix)[n]) {
+		return(*papColorSpaces);
+	    }
+	    papColorSpaces++;
+	}
+    }
+
+    /*
+     * Next try Device-Dependent color spaces
+     */
+    papColorSpaces = ((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->DDColorSpaces;
+    if (papColorSpaces != NULL) {
+	while (*papColorSpaces != NULL) {
+	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0 &&
+		!((*papColorSpaces)->prefix)[n]) {
+		return(*papColorSpaces);
+	    }
+	    papColorSpaces++;
+	}
+    }
+
+    return(NULL);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsParseColorString
+ *
+ *	SYNOPSIS
+ */
+static int
+_XcmsParseColorString(
+    XcmsCCC ccc,
+    const char *color_string,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Assuming color_string contains a numerical string color
+ *		specification, attempts to parse a string into an
+ *		XcmsColor structure.
+ *
+ *	RETURNS
+ *		0 if failed; otherwise non-zero.
+ *
+ *	CAVEATS
+ *		A color string containing a numerical color specification
+ *		must be in ISO Latin-1 encoding!
+ */
+{
+    XcmsColorSpace	*pColorSpace;
+    char		string_buf[64];
+    char		*string_lowered;
+    int			len;
+    int			res;
+
+    if (ccc == NULL) {
+	return(0);
+    }
+
+    /*
+     * While copying color_string to string_lowered, convert to lowercase
+     */
+    if ((len = strlen(color_string)) >= sizeof(string_buf)) {
+	string_lowered = (char *) Xmalloc(len+1);
+    } else {
+	string_lowered = string_buf;
+    }
+
+    _XcmsCopyISOLatin1Lowered(string_lowered, color_string);
+
+    if (*string_lowered == '#') {
+	if ((pColorSpace = _XcmsColorSpaceOfString(ccc, "rgb:")) != NULL) {
+	    res = (*pColorSpace->parseString)(string_lowered, pColor);
+	    if (len >= sizeof(string_buf)) Xfree(string_lowered);
+	    return res;
+	}
+    }
+
+    if ((pColorSpace = _XcmsColorSpaceOfString(ccc, string_lowered)) != NULL) {
+	res = (*pColorSpace->parseString)(string_lowered, pColor);
+	if (len >= sizeof(string_buf)) Xfree(string_lowered);
+	return res;
+    }
+
+    if (len >= sizeof(string_buf)) Xfree(string_lowered);
+    return(0);
+}
+
+
+/*
+ *	NAME
+ *		FirstCmp - Compare color names of pair recs
+ *
+ *	SYNOPSIS
+ */
+static int
+FirstCmp(const void *p1, const void *p2)
+/*
+ *	DESCRIPTION
+ *		Compares the color names of XcmsColorTuples.
+ *		This routine is public to allow access from qsort???.
+ *
+ *	RETURNS
+ *		0 if equal;
+ *		< 0 if first precedes second,
+ *		> 0 if first succeeds second.
+ *
+ */
+{
+    return(strcmp(((XcmsPair *)p1)->first, ((XcmsPair *)p2)->first));
+}
+
+
+
+/*
+ *	NAME
+ *		stringSectionSize - determine memory needed for strings
+ *
+ *	SYNOPSIS
+ */
+static void
+SetNoVisit(void)
+/*
+ *	DESCRIPTION
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    int i;
+    XcmsPair *pair = pairs;
+
+    for (i = 0; i < nEntries; i++, pair++) {
+	if (pair->flag != CYCLE) {
+	    pair->flag = NOT_VISITED;
+	}
+    }
+}
+
+
+
+
+/*
+ *	NAME
+ *		field2 - extract two fields
+ *
+ *	SYNOPSIS
+ */
+static int
+field2(
+    char *pBuf,
+    char delim,	/* in:  field delimiter */
+    char **p1,	/* in/out: pointer to pointer to field 1 */
+    char **p2)	/* in/out: pointer to pointer to field 2 */
+/*
+ *	DESCRIPTION
+ *		Extracts two fields from a "record".
+ *
+ *	RETURNS
+ *		XcmsSuccess if succeeded, otherwise XcmsFailure.
+ *
+ */
+{
+    *p1 = *p2 = NULL;
+
+    /* Find Field 1 */
+    while (!isgraph(*pBuf)) {
+	if ((*pBuf != '\n') || (*pBuf != '\0')) {
+	    return(XcmsFailure);
+	}
+	if (isspace(*pBuf) || (*pBuf == delim)) {
+	    pBuf++;
+	}
+    }
+    *p1 = pBuf;
+
+    /* Find end of Field 2 */
+    while (isprint(*pBuf) && (*pBuf != delim)) {
+	pBuf++;
+    }
+    if ((*pBuf == '\n') || (*pBuf == '\0')) {
+	return(XcmsFailure);
+    }
+    if ((*pBuf == ' ') || (*pBuf == delim)) {
+	*pBuf++ = '\0';	/* stuff end of string character */
+    } else {
+	return(XcmsFailure);
+    }
+
+    /* Find Field 2 */
+    while (!isgraph(*pBuf)) {
+	if ((*pBuf == '\n') || (*pBuf == '\0')) {
+	    return(XcmsFailure);
+	}
+	if (isspace(*pBuf) || (*pBuf == delim)) {
+	    pBuf++;
+	}
+    }
+    *p2 = pBuf;
+
+    /* Find end of Field 2 */
+    while (isprint(*pBuf) && (*pBuf != delim)) {
+	pBuf++;
+    }
+    if (*pBuf != '\0') {
+	*pBuf = '\0';	/* stuff end of string character */
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsLookupColorName - Lookup DB entry for a color name
+ *
+ *	SYNOPSIS
+ */
+static Status
+_XcmsLookupColorName(
+    XcmsCCC ccc,
+    const char **name,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Searches for an entry in the Device-Independent Color Name
+ *		Database for the specified string.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed to find a matching entry in
+ *			the database.
+ *		XcmsSuccess if succeeded in converting color name to
+ *			XcmsColor.
+ *		_XCMS_NEWNAME if succeeded in converting color string (which
+ *			is a color name to yet another color name.  Note
+ *			that the new name is passed back via 'name'.
+ */
+ {
+    Status		retval = 0;
+    char		name_lowered_64[64];
+    char		*name_lowered;
+    register int	i, j, left, right;
+    int			len;
+    const char		*tmpName;
+    XcmsPair		*pair = NULL;
+
+    /*
+     * Check state of Database:
+     *		XcmsDbInitNone
+     *		XcmsDbInitSuccess
+     *		XcmsDbInitFailure
+     */
+    if (XcmsColorDbState == XcmsDbInitFailure) {
+	return(XcmsFailure);
+    }
+    if (XcmsColorDbState == XcmsDbInitNone) {
+	if (!LoadColornameDB()) {
+	    return(XcmsFailure);
+	}
+    }
+
+    SetNoVisit();
+
+    /*
+     * While copying name to name_lowered, convert to lowercase
+     */
+
+    tmpName = *name;
+
+Retry:
+    if ((len = strlen(tmpName)) > 63) {
+	name_lowered = (char *) Xmalloc(len+1);
+    } else {
+	name_lowered = name_lowered_64;
+    }
+
+    _XcmsCopyISOLatin1Lowered(name_lowered, tmpName);
+
+    /*
+     * Now, remove spaces.
+     */
+    for (i = 0, j = 0; j < len; j++) {
+	if (!isspace(name_lowered[j])) {
+	    name_lowered[i++] = name_lowered[j];
+	}
+    }
+    name_lowered[i] = '\0';
+
+    left = 0;
+    right = nEntries - 1;
+    while (left <= right) {
+	i = (left + right) >> 1;
+	pair = &pairs[i];
+	j = strcmp(name_lowered, pair->first);
+	if (j < 0)
+	    right = i - 1;
+	else if (j > 0)
+	    left = i + 1;
+	else {
+	    break;
+	}
+    }
+    if (len > 63) Xfree(name_lowered);
+
+    if (left > right) {
+	if (retval == 2) {
+	    if (*name != tmpName) {
+		*name = tmpName;
+	    }
+	    return(_XCMS_NEWNAME);
+	}
+	return(XcmsFailure);
+    }
+
+    if (pair->flag == CYCLE) {
+	return(XcmsFailure);
+    }
+    if (pair->flag == VISITED) {
+	pair->flag = CYCLE;
+	return(XcmsFailure);
+    }
+
+    if (_XcmsParseColorString(ccc, pair->second, pColor) == XcmsSuccess) {
+	/* f2 contains a numerical string specification */
+	return(XcmsSuccess);
+    } else {
+	/* f2 does not contain a numerical string specification */
+	tmpName = pair->second;
+	pair->flag = VISITED;
+	retval = 2;
+	goto Retry;
+    }
+}
+
+
+/*
+ *	NAME
+ *		RemoveSpaces
+ *
+ *	SYNOPSIS
+ */
+static int
+RemoveSpaces(
+    char *pString)
+/*
+ *	DESCRIPTION
+ *		Removes spaces from string.
+ *
+ *	RETURNS
+ *		Void
+ *
+ */
+{
+    int i, count = 0;
+    char *cptr;
+
+    /* REMOVE SPACES */
+    cptr = pString;
+    for (i = strlen(pString); i; i--, cptr++) {
+	if (!isspace(*cptr)) {
+	    *pString++ = *cptr;
+	    count++;
+	}
+    }
+    *pString = '\0';
+    return(count);
+}
+
+
+/*
+ *	NAME
+ *		stringSectionSize - determine memory needed for strings
+ *
+ *	SYNOPSIS
+ */
+static int
+stringSectionSize(
+    FILE *stream,
+    int	*pNumEntries,
+    int	*pSectionSize)
+/*
+ *	DESCRIPTION
+ *		Determines the amount of memory required to store the
+ *		color name strings and also the number of strings.
+ *
+ *	RETURNS
+ *		XcmsSuccess if succeeded, otherwise XcmsFailure.
+ *
+ */
+{
+    char buf[XCMSDB_MAXLINELEN];
+    char token[XCMSDB_MAXLINELEN];
+    char token2[XCMSDB_MAXLINELEN];
+    char *pBuf;
+    char *f1;
+    char *f2;
+    int i;
+
+    *pNumEntries = 0;
+    *pSectionSize = 0;
+
+    /*
+     * Advance to START_TOKEN
+     *	 Anything before is just considered as comments.
+     */
+
+    while((pBuf = fgets(buf, XCMSDB_MAXLINELEN, stream)) != NULL) {
+	if ((sscanf(buf, "%s %s", token, token2))
+		&& (strcmp(token, START_TOKEN) == 0)) {
+	    if (strcmp(token2, FORMAT_VERSION) != 0) {
+		/* text file not in the right format */
+		return(XcmsFailure);
+	    }
+	    break;
+	} /* else it was just a blank line or comment */
+    }
+
+    if (pBuf == NULL) {
+	return(XcmsFailure);
+    }
+
+    while((pBuf = fgets(buf, XCMSDB_MAXLINELEN, stream)) != NULL) {
+	if ((sscanf(buf, "%s", token)) && (strcmp(token, END_TOKEN) == 0)) {
+	    break;
+	}
+
+	if (field2(buf, DELIM_CHAR, &f1, &f2) != XcmsSuccess) {
+	    return(XcmsFailure);
+	}
+
+	(*pNumEntries)++;
+
+	(*pSectionSize) += (i = strlen(f1)) + 1;
+	for (; i; i--, f1++) {
+	    /* REMOVE SPACES FROM COUNT */
+	    if (isspace(*f1)) {
+		(*pSectionSize)--;
+	    }
+	}
+
+	(*pSectionSize) += (i = strlen(f2)) + 1;
+	for (; i; i--, f2++) {
+	    /* REMOVE SPACES FROM COUNT */
+	    if (isspace(*f2)) {
+		(*pSectionSize)--;
+	    }
+	}
+
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		ReadColornameDB - Read the Color Name Database
+ *
+ *	SYNOPSIS
+ */
+static Status
+ReadColornameDB(
+    FILE *stream,
+    XcmsPair *pRec,
+    char *pString)
+/*
+ *	DESCRIPTION
+ *		Loads the Color Name Database from a text file.
+ *
+ *	RETURNS
+ *		XcmsSuccess if succeeded, otherwise XcmsFailure.
+ *
+ */
+{
+    char buf[XCMSDB_MAXLINELEN];
+    char token[XCMSDB_MAXLINELEN];
+    char token2[XCMSDB_MAXLINELEN];
+    char *f1;
+    char *f2;
+    char *pBuf;
+
+    /*
+     * Advance to START_TOKEN
+     *	 Anything before is just considered as comments.
+     */
+
+    while((pBuf = fgets(buf, XCMSDB_MAXLINELEN, stream)) != NULL) {
+	if ((sscanf(buf, "%s %s", token, token2))
+		&& (strcmp(token, START_TOKEN) == 0)) {
+	    if (strcmp(token2, FORMAT_VERSION) != 0) {
+		/* text file not in the right format */
+		return(XcmsFailure);
+	    }
+	    break;
+	} /* else it was just a blank line or comment */
+    }
+
+    if (pBuf == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Process lines between START_TOKEN to END_TOKEN
+     */
+
+    while ((pBuf = fgets(buf, XCMSDB_MAXLINELEN, stream)) != NULL) {
+	if ((sscanf(buf, "%s", token)) && (strcmp(token, END_TOKEN) == 0)) {
+	    /*
+	     * Found END_TOKEN so break out of for loop
+	     */
+	    break;
+	}
+
+	/*
+	 * Get pairs
+	 */
+	if (field2(buf, DELIM_CHAR, &f1, &f2) != XcmsSuccess) {
+	    /* Invalid line */
+	    continue;
+	}
+
+	/*
+	 * Add strings
+	 */
+
+	/* Left String */
+	pRec->first = pString;
+	_XcmsCopyISOLatin1Lowered(pString, f1);
+	pString += (1 + RemoveSpaces(pString));
+	pRec->second = pString;
+	/* Right String */
+	_XcmsCopyISOLatin1Lowered(pString, f2);
+	pString += RemoveSpaces(pString) + 1;
+	pRec++;
+
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		LoadColornameDB - Load the Color Name Database
+ *
+ *	SYNOPSIS
+ */
+static Status
+LoadColornameDB(void)
+/*
+ *	DESCRIPTION
+ *		Loads the Color Name Database from a text file.
+ *
+ *	RETURNS
+ *		XcmsSuccess if succeeded, otherwise XcmsFailure.
+ *
+ */
+{
+    int size;
+    FILE *stream;
+    const char *pathname;
+    struct stat txt;
+    int length;
+
+    /* use and name of this env var is not part of the standard */
+    /* implementation-dependent feature */
+    if ((pathname = getenv("XCMSDB")) == NULL) {
+	pathname = XCMSDB;
+    }
+#ifdef __UNIXOS2__
+    pathname = __XOS2RedirRoot(pathname);
+#endif
+
+    length = strlen(pathname);
+    if ((length == 0) || (length >= (BUFSIZ - 5))){
+	XcmsColorDbState = XcmsDbInitFailure;
+	return(XcmsFailure);
+    }
+
+    if (stat(pathname, &txt)) {
+	/* can't stat file */
+	XcmsColorDbState = XcmsDbInitFailure;
+	return(XcmsFailure);
+    }
+
+//  if ((stream = _XFopenFile (pathname, "r")) == NULL) {
+    if ((stream = fopen (pathname, "r")) == NULL) {
+	/* can't open file */
+	XcmsColorDbState = XcmsDbInitFailure;
+	return(XcmsFailure);
+    }
+
+    if (stringSectionSize(stream, &nEntries, &size) != XcmsSuccess ||
+	nEntries == 0) {
+	(void) fclose(stream);
+	XcmsColorDbState = XcmsDbInitFailure;
+	return(XcmsFailure);
+    }
+    rewind(stream);
+
+    strings = (char *) Xmalloc(size);
+    pairs = (XcmsPair *)Xcalloc(nEntries, sizeof(XcmsPair));
+
+    ReadColornameDB(stream, pairs, strings);
+    (void) fclose(stream);
+
+    /*
+     * sort the pair recs
+     */
+    qsort((char *)pairs, nEntries, sizeof(XcmsPair), FirstCmp);
+
+    XcmsColorDbState = XcmsDbInitSuccess;
+    return(XcmsSuccess);
+}
+
+
+/************************************************************************
+ *									*
+ *			API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsCopyISOLatin1Lowered
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsCopyISOLatin1Lowered(
+    char *dst,
+    const char *src)
+/*
+ *	DESCRIPTION
+ *		ISO Latin-1 case conversion routine
+ *		Identical to XmuCopyISOLatin1Lowered() but provided here
+ *		to eliminate need to link with libXmu.a.
+ *
+ *		IMPLEMENTORS NOTE:
+ *		    This routine is also used in XcmsFormatOfPrefix.
+ *
+ *	RETURNS
+ *		Void
+ *
+ */
+{
+    register unsigned char *dest;
+    register const unsigned char *source;
+
+    for (dest = (unsigned char *)dst, source = (const unsigned char *)src;
+	 *source;
+	 source++, dest++)
+    {
+	if ((*source >= XK_A) && (*source <= XK_Z))
+	    *dest = *source + (XK_a - XK_A);
+	else if ((*source >= XK_Agrave) && (*source <= XK_Odiaeresis))
+	    *dest = *source + (XK_agrave - XK_Agrave);
+	else if ((*source >= XK_Ooblique) && (*source <= XK_Thorn))
+	    *dest = *source + (XK_oslash - XK_Ooblique);
+	else
+	    *dest = *source;
+    }
+    *dest = '\0';
+}
+
+
+/*
+ *	NAME
+ *		_XcmsResolveColorString -
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsResolveColorString (
+    XcmsCCC ccc,
+    const char **color_string,
+    XcmsColor *pColor_exact_return,
+    XcmsColorFormat result_format)
+/*
+ *	DESCRIPTION
+ *		The XcmsLookupColor function finds the color specification
+ *		associated with a color name in the Device-Independent Color
+ *		Name Database.
+ *	RETURNS
+ *		XcmsFailure if failed to convert valid color string.
+ *		XcmsSuccess if succeeded in converting color string to
+ *			XcmsColor.
+ *		_XCMS_NEWNAME if failed to parse the string or find it in
+ *			the database, or if succeeded in looking it up and
+ *			found another name which is not in the database.
+ *			Note that the new name is returned in color_string.
+ *
+ *		This function returns both the color specification found in the
+ *		database (db specification) and the color specification for the
+ *		color displayable by the specified screen (screen
+ *		specification).  The calling routine sets the format for these
+ *		returned specifications in the XcmsColor format component.
+ *		If XcmsUndefinedFormat, the specification is returned in the
+ *		format used to store the color in the database.
+ */
+{
+    XcmsColor dbWhitePt;	/* whitePt associated with pColor_exact_return*/
+				/*    the screen's white point */
+    XcmsColor *pClientWhitePt;
+    int retval;
+    const char *strptr = whitePtStr;
+
+/*
+ * 0. Check for invalid arguments.
+ */
+    if (ccc == NULL || (*color_string)[0] == '\0' || pColor_exact_return == NULL) {
+	return(XcmsFailure);
+    }
+
+/*
+ * 1. First attempt to parse the string
+ *    If successful, then convert the specification to the target format
+ *    and return.
+ */
+    if (_XcmsParseColorString(ccc, *color_string, pColor_exact_return)
+	    == 1) {
+	if (result_format != XcmsUndefinedFormat
+		&& pColor_exact_return->format != result_format) {
+	    /* need to be converted to the target format */
+	    return(XcmsConvertColors(ccc, pColor_exact_return, 1,
+		    result_format, (Bool *)NULL));
+	} else {
+	    return(XcmsSuccess);
+	}
+    }
+
+/*
+ * 2. Attempt to find it in the DI Color Name Database
+ */
+
+    /*
+     * a. Convert String into a XcmsColor structure
+     *       Attempt to extract the specification for color_string from the
+     *       DI Database (pColor_exact_return).  If the DI Database does not
+     *	     have this entry, then return failure.
+     */
+    retval = _XcmsLookupColorName(ccc, color_string, pColor_exact_return);
+
+    if (retval != XcmsSuccess) {
+	/* color_string replaced with a color name, or not found */
+	return(_XCMS_NEWNAME);
+    }
+
+    if (pColor_exact_return->format == XcmsUndefinedFormat) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * b. If result_format not defined, then assume target format
+     *	  is the exact format.
+     */
+    if (result_format == XcmsUndefinedFormat) {
+	result_format = pColor_exact_return->format;
+    }
+
+    if ((ClientWhitePointOfCCC(ccc))->format == XcmsUndefinedFormat) {
+	pClientWhitePt = ScreenWhitePointOfCCC(ccc);
+    } else {
+	pClientWhitePt = ClientWhitePointOfCCC(ccc);
+    }
+
+    /*
+     * c. Convert to the target format, making adjustments for white
+     *	  point differences as necessary.
+     */
+    if (XCMS_DD_ID(pColor_exact_return->format)) {
+	/*
+	 * The spec format is Device-Dependent, therefore assume the
+	 *    its white point is the Screen White Point.
+	 */
+	if (XCMS_DD_ID(result_format)) {
+	    /*
+	     * Target format is Device-Dependent
+	     *	Therefore, DD --> DD conversion
+	     */
+	    return(_XcmsDDConvertColors(ccc, pColor_exact_return,
+		    1, result_format, (Bool *) NULL));
+	} else {
+	    /*
+	     * Target format is Device-Independent
+	     *	Therefore, DD --> DI conversion
+	     */
+	    if (ccc->whitePtAdjProc && !_XcmsEqualWhitePts(ccc,
+		    pClientWhitePt, ScreenWhitePointOfCCC(ccc))) {
+		return((*ccc->whitePtAdjProc)(ccc, ScreenWhitePointOfCCC(ccc),
+			pClientWhitePt, result_format,
+			pColor_exact_return, 1, (Bool *) NULL));
+	    } else {
+		if (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
+			XcmsCIEXYZFormat, (Bool *) NULL) == XcmsFailure) {
+		    return(XcmsFailure);
+		}
+		return(_XcmsDIConvertColors(ccc, pColor_exact_return,
+			pClientWhitePt, 1, result_format));
+	    }
+	}
+    } else {
+	/*
+	 * The spec format is Device-Independent, therefore attempt
+	 * to find a database white point.
+	 *
+	 * If the Database does not have a white point, then assume the
+	 * database white point is the same as the Screen White Point.
+	 */
+
+	if (_XcmsLookupColorName(ccc, &strptr, &dbWhitePt) != 1) {
+	    memcpy((char *)&dbWhitePt,
+		   (char *)&ccc->pPerScrnInfo->screenWhitePt,
+		   sizeof(XcmsColor));
+	}
+	if (XCMS_DD_ID(result_format)) {
+	    /*
+	     * Target format is Device-Dependent
+	     *	Therefore, DI --> DD conversion
+	     */
+	    if (ccc->whitePtAdjProc && !_XcmsEqualWhitePts(ccc,
+		    &dbWhitePt, ScreenWhitePointOfCCC(ccc))) {
+		return((*ccc->whitePtAdjProc)(ccc, &dbWhitePt,
+			ScreenWhitePointOfCCC(ccc), result_format,
+			pColor_exact_return, 1, (Bool *)NULL));
+	    } else {
+		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
+		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
+			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
+			return(XcmsFailure);
+		    }
+		}
+		return (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
+			result_format, (Bool *)NULL));
+	    }
+	} else {
+	    /*
+	     * Target format is Device-Independent
+	     *	Therefore, DI --> DI conversion
+	     */
+	    if (ccc->whitePtAdjProc && !_XcmsEqualWhitePts(ccc,
+		    &dbWhitePt, pClientWhitePt)) {
+		/*
+		 * The calling routine wants to resolve this color
+		 * in terms if it's white point (i.e. Client White Point).
+		 * Therefore, apply white adjustment for the displacement
+		 * between dbWhitePt to clientWhitePt.
+		 */
+		return((*ccc->whitePtAdjProc)(ccc, &dbWhitePt,
+			pClientWhitePt, result_format,
+			pColor_exact_return, 1, (Bool *)NULL));
+	    } else if (_XcmsEqualWhitePts(ccc,
+		    &dbWhitePt, pClientWhitePt)) {
+		/*
+		 * Can use either dbWhitePt or pClientWhitePt to
+		 * convert to the result_format.
+		 */
+		if (pColor_exact_return->format == result_format) {
+		    return(XcmsSuccess);
+		} else {
+		    return (_XcmsDIConvertColors(ccc, pColor_exact_return,
+			    &dbWhitePt, 1, result_format));
+		}
+	    } else {
+		/*
+		 * Need to convert to a white point independent color
+		 * space (let's choose CIEXYZ) then convert to the
+		 * target color space.  Why? Lets assume that
+		 * pColor_exact_return->format and result format
+		 * are white point dependent format (e.g., CIELUV, CIELAB,
+		 * TekHVC ... same or any combination). If so, we'll
+		 * need to convert the color with dbWhitePt to an absolute
+		 * spec (i.e.  non-white point dependent) then convert that
+		 * absolute value with clientWhitePt to the result_format.
+		 */
+		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
+		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
+			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
+			return(XcmsFailure);
+		    }
+		}
+		if (result_format == XcmsCIEXYZFormat) {
+		    return(XcmsSuccess);
+		} else {
+		    return(_XcmsDIConvertColors(ccc, pColor_exact_return,
+			    pClientWhitePt, 1, result_format));
+		}
+	    }
+	}
+    }
+}
diff --git a/libtinyX11/cmsGlobls.c b/libtinyX11/cmsGlobls.c
new file mode 100644
index 0000000..c9e82f2
--- /dev/null
+++ b/libtinyX11/cmsGlobls.c
@@ -0,0 +1,126 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsGlobls.c
+ *
+ *	DESCRIPTION
+ *		Source file containing Xcms globals
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *      GLOBALS
+ *              Variables declared in this package that are allowed
+ *		to be used globally.
+ */
+
+    /*
+     * Initial array of Device Independent Color Spaces
+     */
+XcmsColorSpace *_XcmsDIColorSpacesInit[] = {
+    &XcmsCIEXYZColorSpace,
+    &XcmsCIEuvYColorSpace,
+    &XcmsCIExyYColorSpace,
+    &XcmsCIELabColorSpace,
+    &XcmsCIELuvColorSpace,
+    &XcmsTekHVCColorSpace,
+    &XcmsUNDEFINEDColorSpace,
+    NULL
+};
+    /*
+     * Pointer to the array of pointers to XcmsColorSpace structures for
+     * Device-Independent Color Spaces that are currently accessible by
+     * the color management system.  End of list is indicated by a NULL pointer.
+     */
+XcmsColorSpace **_XcmsDIColorSpaces = _XcmsDIColorSpacesInit;
+
+    /*
+     * Initial array of Device Dependent Color Spaces
+     */
+XcmsColorSpace *_XcmsDDColorSpacesInit[] = {
+    &XcmsRGBColorSpace,
+    &XcmsRGBiColorSpace,
+    NULL
+};
+    /*
+     * Pointer to the array of pointers to XcmsColorSpace structures for
+     * Device-Dependent Color Spaces that are currently accessible by
+     * the color management system.  End of list is indicated by a NULL pointer.
+     */
+XcmsColorSpace **_XcmsDDColorSpaces = &_XcmsDDColorSpacesInit[0];
+
+    /*
+     * Initial array of Screen Color Characterization Function Sets
+     */
+XcmsFunctionSet	*_XcmsSCCFuncSetsInit[] = {
+	&XcmsLinearRGBFunctionSet,
+#ifdef GRAY
+	&XcmsGrayFunctionSet,
+#endif /* GRAY */
+	NULL};
+    /*
+     * Pointer to the array of pointers to XcmsSCCFuncSet structures
+     * (Screen Color Characterization Function Sets) that are currently
+     * accessible by the color management system.  End of list is
+     * indicated by a NULL pointer.
+     */
+XcmsFunctionSet **_XcmsSCCFuncSets = _XcmsSCCFuncSetsInit;
+
+    /*
+     * X Consortium Registered Device-Independent Color Spaces
+     *	Note that prefix must be in lowercase.
+     */
+const char	_XcmsCIEXYZ_prefix[] = "ciexyz";
+const char	_XcmsCIEuvY_prefix[] = "cieuvy";
+const char	_XcmsCIExyY_prefix[] = "ciexyy";
+const char	_XcmsCIELab_prefix[] = "cielab";
+const char 	_XcmsCIELuv_prefix[] = "cieluv";
+const char	_XcmsTekHVC_prefix[] = "tekhvc";
+    /*
+     * Registered Device-Dependent Color Spaces
+     */
+const char	_XcmsRGBi_prefix[] = "rgbi";
+const char	_XcmsRGB_prefix[] = "rgb";
+
+XcmsRegColorSpaceEntry _XcmsRegColorSpaces[] = {
+    { _XcmsCIEXYZ_prefix, XcmsCIEXYZFormat },
+    { _XcmsCIEuvY_prefix, XcmsCIEuvYFormat },
+    { _XcmsCIExyY_prefix, XcmsCIExyYFormat },
+    { _XcmsCIELab_prefix, XcmsCIELabFormat },
+    { _XcmsCIELuv_prefix, XcmsCIELuvFormat },
+    { _XcmsTekHVC_prefix, XcmsTekHVCFormat },
+    { _XcmsRGB_prefix, XcmsRGBFormat },
+    { _XcmsRGBi_prefix,	XcmsRGBiFormat },
+    { NULL, 0 }
+};
diff --git a/libtinyX11/cmsInt.c b/libtinyX11/cmsInt.c
new file mode 100644
index 0000000..b480365
--- /dev/null
+++ b/libtinyX11/cmsInt.c
@@ -0,0 +1,413 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		XcmsInt.c - Xcms API utility routines
+ *
+ *	DESCRIPTION
+ *		Xcms Application Program Interface (API) utility
+ *		routines for hanging information directly onto
+ *		the Display structure.
+ *
+ *
+ */
+
+/* #define NEED_EVENTS */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdio.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+#ifndef XCMSCOMPPROC
+#  define XCMSCOMPPROC	XcmsTekHVCClipC
+#endif
+
+/* forward/static */
+static void _XcmsFreeDefaultCCCs(Display *dpy);
+
+
+/************************************************************************
+ *									*
+ *			   API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		_XcmsCopyPointerArray
+ *
+ *	SYNOPSIS
+ */
+XPointer *
+_XcmsCopyPointerArray(
+    XPointer *pap)
+/*
+ *	DESCRIPTION
+ *		Copies an array of NULL terminated pointers.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the copy.
+ *
+ */
+{
+    XPointer *newArray;
+    char **tmp;
+    int n;
+
+    for (tmp = pap, n = 0; *tmp != NULL; tmp++, n++);
+    n++; /* add 1 to include the NULL pointer */
+
+    if ((newArray = (XPointer *)Xmalloc(n * sizeof(XPointer)))) {
+	memcpy((char *)newArray, (char *)pap,
+	       (unsigned)(n * sizeof(XPointer)));
+    }
+    return((XPointer *)newArray);
+}
+
+/*
+ *	NAME
+ *		_XcmsFreePointerArray
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsFreePointerArray(
+    XPointer *pap)
+/*
+ *	DESCRIPTION
+ *		Frees an array of NULL terminated pointers.
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    Xfree(pap);
+}
+
+/*
+ *	NAME
+ *		_XcmsPushPointerArray
+ *
+ *	SYNOPSIS
+ */
+XPointer *
+_XcmsPushPointerArray(
+    XPointer *pap,
+    XPointer p,
+    XPointer *papNoFree)
+/*
+ *	DESCRIPTION
+ *		Places the specified pointer at the head of an array of NULL
+ *		terminated pointers.
+ *
+ *	RETURNS
+ *		Returns NULL if failed; otherwise the address to
+ *		the head of the array.
+ *
+ */
+{
+    XPointer *newArray;
+    char **tmp;
+    int n;
+
+    for (tmp = pap, n = 0; *tmp != NULL; tmp++, n++);
+
+    /* add 2: 1 for the new pointer and another for the NULL pointer */
+    n += 2;
+
+    if ((newArray = (XPointer *)Xmalloc(n * sizeof(XPointer)))) {
+	memcpy((char *)(newArray+1),(char *)pap,
+	       (unsigned)((n-1) * sizeof(XPointer)));
+	*newArray = p;
+    }
+    if (pap != papNoFree) {
+        _XcmsFreePointerArray(pap);
+    }
+    return((XPointer *)newArray);
+}
+
+/*
+ *	NAME
+ *		_XcmsInitDefaultCCCs
+ *
+ *	SYNOPSIS
+ */
+int
+_XcmsInitDefaultCCCs(
+    Display *dpy)
+/*
+ *	DESCRIPTION
+ *		Initializes the Xcms per Display Info structure
+ *		(XcmsPerDpyInfo).
+ *
+ *	RETURNS
+ *		Returns 0 if failed; otherwise non-zero.
+ *
+ */
+{
+    int nScrn = ScreenCount(dpy);
+    int i;
+    XcmsCCC ccc;
+
+    if (nScrn <= 0) {
+	return(0);
+    }
+
+    /*
+     * Create an array of XcmsCCC structures, one for each screen.
+     * They serve as the screen's default CCC.
+     */
+    if (!(ccc = (XcmsCCC)
+	    Xcalloc((unsigned)nScrn, (unsigned) sizeof(XcmsCCCRec)))) {
+	return(0);
+    }
+    dpy->cms.defaultCCCs = (XPointer)ccc;
+    dpy->free_funcs->defaultCCCs = _XcmsFreeDefaultCCCs;
+
+    for (i = 0; i < nScrn; i++, ccc++) {
+	ccc->dpy = dpy;
+	ccc->screenNumber = i;
+	ccc->visual = DefaultVisual(dpy, i);
+	/*
+	 * Used calloc to allocate memory so:
+	 *	ccc->clientWhitePt->format == XcmsUndefinedFormat
+	 *	ccc->gamutCompProc == NULL
+	 *	ccc->whitePtAdjProc == NULL
+	 *	ccc->pPerScrnInfo = NULL
+	 *
+	 * Don't need to create XcmsPerScrnInfo and its functionSet and
+	 * pScreenData components until the default CCC is accessed.
+	 * Note that the XcmsDefaultCCC routine calls _XcmsInitScrnInto
+	 * to do this.
+	 */
+	ccc->gamutCompProc = XCMSCOMPPROC;
+    }
+
+    return(1);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsFreeDefaultCCCs - Free Default CCCs and its PerScrnInfo
+ *
+ *	SYNOPSIS
+ */
+static void
+_XcmsFreeDefaultCCCs(
+    Display *dpy)
+/*
+ *	DESCRIPTION
+ *		This routine frees the default XcmsCCC's associated with
+ *		each screen and its associated substructures as neccessary.
+ *
+ *	RETURNS
+ *		void
+ *
+ *
+ */
+{
+    int nScrn = ScreenCount(dpy);
+    XcmsCCC ccc;
+    int i;
+
+    /*
+     * Free Screen data in each DefaultCCC
+     *		Do not use XcmsFreeCCC here because it will not free
+     *		DefaultCCC's.
+     */
+    ccc = (XcmsCCC)dpy->cms.defaultCCCs;
+    for (i = nScrn; i--; ccc++) {
+	/*
+	 * Check if XcmsPerScrnInfo exists.
+	 *
+	 * This is the only place where XcmsPerScrnInfo structures
+	 * are freed since there is only one allocated per Screen.
+	 * It just so happens that we place its reference in the
+	 * default CCC.
+	 */
+	if (ccc->pPerScrnInfo) {
+	    /* Check if SCCData exists */
+	    if (ccc->pPerScrnInfo->state != XcmsInitNone
+		    && ccc->pPerScrnInfo->screenData) {
+		(*((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->screenFreeProc)
+			(ccc->pPerScrnInfo->screenData);
+	    }
+	    Xfree(ccc->pPerScrnInfo);
+	}
+    }
+
+    /*
+     * Free the array of XcmsCCC structures
+     */
+    Xfree(dpy->cms.defaultCCCs);
+    dpy->cms.defaultCCCs = (XPointer)NULL;
+}
+
+
+
+/*
+ *	NAME
+ *		_XcmsInitScrnInfo
+ *
+ *	SYNOPSIS
+ */
+int
+_XcmsInitScrnInfo(
+    register Display *dpy,
+    int screenNumber)
+/*
+ *	DESCRIPTION
+ *		Given a display and screen number, this routine attempts
+ *		to initialize the Xcms per Screen Info structure
+ *		(XcmsPerScrnInfo).
+ *
+ *	RETURNS
+ *		Returns zero if initialization failed; non-zero otherwise.
+ */
+{
+    XcmsFunctionSet **papSCCFuncSet = _XcmsSCCFuncSets;
+    XcmsCCC defaultccc;
+
+    /*
+     * Check if the XcmsCCC's for each screen has been created.
+     * Really dont need to be created until some routine uses the Xcms
+     * API routines.
+     */
+    if ((XcmsCCC)dpy->cms.defaultCCCs == NULL) {
+	if (!_XcmsInitDefaultCCCs(dpy)) {
+	    return(0);
+	}
+    }
+
+    defaultccc = (XcmsCCC)dpy->cms.defaultCCCs + screenNumber;
+
+    /*
+     * For each SCCFuncSet, try its pInitScrnFunc.
+     *	If the function succeeds, then we got it!
+     */
+
+    if (!defaultccc->pPerScrnInfo) {
+	/*
+	 * This is one of two places where XcmsPerScrnInfo structures
+	 * are allocated.  There is one allocated per Screen that is
+	 * shared among visuals that do not have specific intensity
+	 * tables.  Other XcmsPerScrnInfo structures are created
+	 * for the latter (see XcmsCreateCCC).  The ones created
+	 * here are referenced by the default CCC.
+	 */
+	if (!(defaultccc->pPerScrnInfo = (XcmsPerScrnInfo *)
+		Xcalloc(1, (unsigned) sizeof(XcmsPerScrnInfo)))) {
+	    return(0);
+	}
+	defaultccc->pPerScrnInfo->state = XcmsInitNone;
+    }
+
+    while (*papSCCFuncSet != NULL) {
+	if ((*(*papSCCFuncSet)->screenInitProc)(dpy, screenNumber,
+		defaultccc->pPerScrnInfo)) {
+	    defaultccc->pPerScrnInfo->state = XcmsInitSuccess;
+	    return(1);
+	}
+	papSCCFuncSet++;
+    }
+
+    /*
+     * Use Default SCCData
+     */
+    return(_XcmsLRGB_InitScrnDefault(dpy, screenNumber, defaultccc->pPerScrnInfo));
+}
+
+
+/*
+ *	NAME
+ *		_XcmsFreeIntensityMaps
+ *
+ *	SYNOPSIS
+ */
+void
+_XcmsFreeIntensityMaps(
+    Display *dpy)
+/*
+ *	DESCRIPTION
+ *		Frees all XcmsIntensityMap structures in the linked list
+ *		and sets dpy->cms.perVisualIntensityMaps to NULL.
+ *
+ *	RETURNS
+ *		void
+ *
+ */
+{
+    XcmsIntensityMap *pNext, *pFree;
+
+    pNext = (XcmsIntensityMap *)dpy->cms.perVisualIntensityMaps;
+    while (pNext != NULL) {
+	pFree = pNext;
+	pNext = pNext->pNext;
+	(*pFree->pFreeScreenData)(pFree->screenData);
+	/* Now free the XcmsIntensityMap structure */
+	Xfree(pFree);
+    }
+    dpy->cms.perVisualIntensityMaps = (XPointer)NULL;
+}
+
+
+/*
+ *	NAME
+ *		_XcmsGetIntensityMap
+ *
+ *	SYNOPSIS
+ */
+XcmsIntensityMap *
+_XcmsGetIntensityMap(
+    Display *dpy,
+    Visual *visual)
+/*
+ *	DESCRIPTION
+ *		Attempts to return a per-Visual intensity map.
+ *
+ *	RETURNS
+ *		Pointer to the XcmsIntensityMap structure if found;
+ *		otherwise NULL
+ *
+ */
+{
+    VisualID targetID = visual->visualid;
+    XcmsIntensityMap *pNext;
+
+    pNext = (XcmsIntensityMap *)dpy->cms.perVisualIntensityMaps;
+    while (pNext != NULL) {
+	if (targetID == pNext->visualID) {
+	    return(pNext);
+	}
+	pNext = pNext->pNext;
+    }
+    return((XcmsIntensityMap *)NULL);
+}
diff --git a/libtinyX11/cmsProp.c b/libtinyX11/cmsProp.c
new file mode 100644
index 0000000..856ae84
--- /dev/null
+++ b/libtinyX11/cmsProp.c
@@ -0,0 +1,146 @@
+
+/*
+ *
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		XcmsProp.c
+ *
+ *	DESCRIPTION
+ *		This utility routines for manipulating properties.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xatom.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+
+/************************************************************************
+ *									*
+ *			API PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+
+/*
+ *	NAME
+ *		_XcmsGetElement -- get an element value from the property passed
+ *
+ *	SYNOPSIS
+ */
+unsigned long
+_XcmsGetElement(
+    int             format,
+    char            **pValue,
+    unsigned long   *pCount)
+/*
+ *	DESCRIPTION
+ *	    Get the next element from the property and return it.
+ *	    Also increment the pointer the amount needed.
+ *
+ *	Returns
+ *	    unsigned long
+ */
+{
+    unsigned long value;
+
+    switch (format) {
+      case 32:
+	value = *((unsigned long *)(*pValue)) & 0xFFFFFFFF;
+	*pValue += sizeof(unsigned long);
+	*pCount -= 1;
+	break;
+      case 16:
+	value = *((unsigned short *)(*pValue));
+	*pValue += sizeof(unsigned short);
+	*pCount -= 1;
+	break;
+      case 8:
+	value = *((unsigned char *) (*pValue));
+	*pValue += 1;
+	*pCount -= 1;
+	break;
+      default:
+	value = 0;
+	break;
+    }
+    return(value);
+}
+
+
+/*
+ *	NAME
+ *		_XcmsGetProperty -- Determine the existance of a property
+ *
+ *	SYNOPSIS
+ */
+int
+_XcmsGetProperty(
+    Display *pDpy,
+    Window  w,
+    Atom property,
+    int             *pFormat,
+    unsigned long   *pNItems,
+    unsigned long   *pNBytes,
+    char            **pValue)
+/*
+ *	DESCRIPTION
+ *
+ *	Returns
+ *	    0 if property does not exist.
+ *	    1 if property exists.
+ */
+{
+    char *prop_ret;
+    int format_ret;
+    long len = 6516;
+    unsigned long nitems_ret, after_ret;
+    Atom atom_ret;
+
+    while (XGetWindowProperty (pDpy, w, property, 0, len, False,
+			       XA_INTEGER, &atom_ret, &format_ret,
+			       &nitems_ret, &after_ret,
+			       (unsigned char **)&prop_ret)) {
+	if (after_ret > 0) {
+	    len += nitems_ret * (format_ret >> 3);
+	    XFree (prop_ret);
+	} else {
+	    break;
+	}
+    }
+    if (format_ret == 0 || nitems_ret == 0) {
+	/* the property does not exist or is of an unexpected type */
+	return(XcmsFailure);
+    }
+
+    *pFormat = format_ret;
+    *pNItems = nitems_ret;
+    *pNBytes = nitems_ret * (format_ret >> 3);
+    *pValue = prop_ret;
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/uvY.c b/libtinyX11/uvY.c
new file mode 100644
index 0000000..5344fb1
--- /dev/null
+++ b/libtinyX11/uvY.c
@@ -0,0 +1,423 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of XCMS based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ *	NAME
+ *		CIEuvy.c
+ *
+ *	DESCRIPTION
+ *		This file contains routines that support the CIE u'v'Y
+ *		color space to include conversions to and from the CIE
+ *		XYZ space.
+ *
+ *	DOCUMENTATION
+ *		"TekColor Color Management System, System Implementor's Manual"
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <X11/Xos.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+#include <stdio.h>
+
+/*
+ *	FORWARD DECLARATIONS
+ */
+static int CIEuvY_ParseString(register char *spec, XcmsColor *pColor);
+
+/*
+ *	DEFINES
+ *		Internal definitions that need NOT be exported to any package
+ *		or program using this package.
+ */
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+
+
+/*
+ *	LOCAL VARIABLES
+ */
+
+    /*
+     * NULL terminated list of functions applied to get from CIEuvY to CIEXYZ
+     */
+static XcmsConversionProc Fl_CIEuvY_to_CIEXYZ[] = {
+    XcmsCIEuvYToCIEXYZ,
+    NULL
+};
+
+    /*
+     * NULL terminated list of functions applied to get from CIEXYZ to CIEuvY
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_CIEuvY[] = {
+    XcmsCIEXYZToCIEuvY,
+    NULL
+};
+
+
+/*
+ *	GLOBALS
+ */
+
+    /*
+     * CIE uvY Color Space
+     */
+XcmsColorSpace	XcmsCIEuvYColorSpace =
+    {
+	_XcmsCIEuvY_prefix,		/* prefix */
+	XcmsCIEuvYFormat,		/* id */
+	CIEuvY_ParseString,	/* parseString */
+	Fl_CIEuvY_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_CIEuvY,	/* from_CIEXYZ */
+	1
+    };
+
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIEuvY_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+CIEuvY_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsCIEuvYFormat.
+ *		The assumed CIEuvY string syntax is:
+ *		    CIEuvY:<u>/<v>/<Y>
+ *		Where u, v, and Y are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsCIEuvY_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.CIEuvY.u_prime,
+	    &pColor->spec.CIEuvY.v_prime,
+	    &pColor->spec.CIEuvY.Y) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.CIEuvY.u_prime,
+		       &pColor->spec.CIEuvY.v_prime,
+		       &pColor->spec.CIEuvY.Y) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	    return(XcmsFailure);
+    }
+    pColor->format = XcmsCIEuvYFormat;
+    pColor->pixel = 0;
+    return(_XcmsCIEuvY_ValidSpec(pColor));
+}
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		XcmsCIEuvY_ValidSpec
+ *
+ *	SYNOPSIS
+ */
+Status
+_XcmsCIEuvY_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks if color specification valid for CIE u'v'Y.
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid,
+ *		XcmsSuccess if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsCIEuvYFormat
+	    ||
+	    (pColor->spec.CIEuvY.Y < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIEuvY.Y > 1.0 + XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEuvYToCIEXYZ - convert CIEuvY to CIEXYZ
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIEuvYToCIEXYZ(
+    XcmsCCC ccc,
+    XcmsColor *puvY_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIEuvY format to CIEXYZ format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsCIEXYZ XYZ_return;
+    XcmsColor whitePt;
+    int i;
+    XcmsColor *pColor = pColors_in_out;
+    XcmsFloat div, x, y, z, Y;
+
+    /*
+     * Check arguments
+     *	Postpone checking puvY_WhitePt until it is actually needed
+     *	otherwise converting between XYZ and uvY will fail.
+     */
+    if (pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is CIEuvY */
+	if (!_XcmsCIEuvY_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/*
+	 * Convert to CIEXYZ
+	 */
+
+	Y = pColor->spec.CIEuvY.Y;
+
+	/* Convert color u'v' to xyz space */
+	div = (6.0 * pColor->spec.CIEuvY.u_prime) - (16.0 * pColor->spec.CIEuvY.v_prime) + 12.0;
+	if (div == 0.0) {
+	    /* use white point since div == 0 */
+	    if (puvY_WhitePt == NULL ) {
+		return(XcmsFailure);
+	    }
+	    /*
+	     * Make sure white point is in CIEuvY form
+	     */
+	    if (puvY_WhitePt->format != XcmsCIEuvYFormat) {
+		/* Make copy of the white point because we're going to modify it */
+		memcpy((char *)&whitePt, (char *)puvY_WhitePt, sizeof(XcmsColor));
+		if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL, 1,
+			XcmsCIEuvYFormat)) {
+		    return(XcmsFailure);
+		}
+		puvY_WhitePt = &whitePt;
+	    }
+	    /* Make sure it is a white point, i.e., Y == 1.0 */
+	    if (puvY_WhitePt->spec.CIEuvY.Y != 1.0) {
+		return(XcmsFailure);
+	    }
+	    div = (6.0 * puvY_WhitePt->spec.CIEuvY.u_prime) -
+		    (16.0 * puvY_WhitePt->spec.CIEuvY.v_prime) + 12.0;
+	    if (div == 0) {
+		/* internal error */
+		return(XcmsFailure);
+	    }
+	    x = 9.0 * puvY_WhitePt->spec.CIEuvY.u_prime / div;
+	    y = 4.0 * puvY_WhitePt->spec.CIEuvY.v_prime / div;
+	} else {
+	    x = 9.0 * pColor->spec.CIEuvY.u_prime / div;
+	    y = 4.0 * pColor->spec.CIEuvY.v_prime / div;
+	}
+	z = 1.0 - x - y;
+
+	/* Convert from xyz to XYZ */
+	/* Conversion uses color normalized lightness based on Y */
+	if (y != 0.0) {
+	    XYZ_return.X = x * Y / y;
+	} else {
+	    XYZ_return.X = x;
+	}
+	XYZ_return.Y = Y;
+	if (y != 0.0) {
+	    XYZ_return.Z = z * Y / y;
+	} else {
+	    XYZ_return.Z = z;
+	}
+
+	memcpy((char *)&pColor->spec.CIEXYZ, (char *)&XYZ_return, sizeof(XcmsCIEXYZ));
+	/* Identify that format is now CIEXYZ */
+	pColor->format = XcmsCIEXYZFormat;
+    }
+
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEXYZToCIEuvY - convert CIEXYZ to CIEuvY
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIEXYZToCIEuvY(
+    XcmsCCC ccc,
+    XcmsColor *puvY_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIEXYZ format to CIEuvY format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsCIEuvY uvY_return;
+    XcmsColor whitePt;
+    int i;
+    XcmsColor *pColor = pColors_in_out;
+    XcmsFloat div;
+
+    /*
+     * Check arguments
+     *	Postpone checking puvY_WhitePt until it is actually needed
+     *	otherwise converting between XYZ and uvY will fail.
+     */
+    if (pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEuvY form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	/* Make sure original format is CIEXYZ */
+	if (!_XcmsCIEXYZ_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	/* Convert to CIEuvY */
+	div = pColor->spec.CIEXYZ.X + (15.0 * pColor->spec.CIEXYZ.Y) +
+		(3.0 * pColor->spec.CIEXYZ.Z);
+	if (div == 0.0) {
+	    /* Use white point since div == 0.0 */
+	    if (puvY_WhitePt == NULL ) {
+		return(XcmsFailure);
+	    }
+	    /*
+	     * Make sure white point is in CIEuvY form
+	     */
+	    if (puvY_WhitePt->format != XcmsCIEuvYFormat) {
+		/* Make copy of the white point because we're going to modify it */
+		memcpy((char *)&whitePt, (char *)puvY_WhitePt, sizeof(XcmsColor));
+		if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL, 1,
+			XcmsCIEuvYFormat)) {
+		    return(XcmsFailure);
+		}
+		puvY_WhitePt = &whitePt;
+	    }
+	    /* Make sure it is a white point, i.e., Y == 1.0 */
+	    if (puvY_WhitePt->spec.CIEuvY.Y != 1.0) {
+		return(XcmsFailure);
+	    }
+	    uvY_return.Y = pColor->spec.CIEXYZ.Y;
+	    uvY_return.u_prime = puvY_WhitePt->spec.CIEuvY.u_prime;
+	    uvY_return.v_prime = puvY_WhitePt->spec.CIEuvY.v_prime;
+	} else {
+	    uvY_return.u_prime = 4.0 * pColor->spec.CIEXYZ.X / div;
+	    uvY_return.v_prime = 9.0 * pColor->spec.CIEXYZ.Y / div;
+	    uvY_return.Y = pColor->spec.CIEXYZ.Y;
+	}
+
+	memcpy((char *)&pColor->spec.CIEuvY, (char *)&uvY_return, sizeof(XcmsCIEuvY));
+	/* Identify that format is now CIEuvY */
+	pColor->format = XcmsCIEuvYFormat;
+    }
+
+    return(XcmsSuccess);
+}
diff --git a/libtinyX11/xyY.c b/libtinyX11/xyY.c
new file mode 100644
index 0000000..6f94574
--- /dev/null
+++ b/libtinyX11/xyY.c
@@ -0,0 +1,395 @@
+
+/*
+ * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
+ * 	All Rights Reserved
+ *
+ * This file is a component of an X Window System-specific implementation
+ * of Xcms based on the TekColor Color Management System.  Permission is
+ * hereby granted to use, copy, modify, sell, and otherwise distribute this
+ * software and its documentation for any purpose and without fee, provided
+ * that this copyright, permission, and disclaimer notice is reproduced in
+ * all copies of this software and in supporting documentation.  TekColor
+ * is a trademark of Tektronix, Inc.
+ *
+ * Tektronix makes no representation about the suitability of this software
+ * for any purpose.  It is provided "as is" and with all faults.
+ *
+ * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,
+ * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.
+ *
+ *	NAME
+ *		CIExyY.c
+ *
+ *	DESCRIPTION
+ *		This file contains routines that support the CIE xyY
+ *		color space to include conversions to and from the CIE
+ *		XYZ space.
+ *
+ *	DOCUMENTATION
+ *		"TekColor Color Management System, System Implementor's Manual"
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdio.h>
+#include <X11/Xos.h>
+#include "Xlibint.h"
+#include "Xcmsint.h"
+#include "Cv.h"
+
+/*
+ *	DEFINES
+ */
+#define EPS 0.00001	/* some extremely small number */
+#ifdef DBL_EPSILON
+#  define XMY_DBL_EPSILON DBL_EPSILON
+#else
+#  define XMY_DBL_EPSILON 0.00001
+#endif
+
+/*
+ *	FORWARD DECLARATIONS
+ */
+
+static int CIExyY_ParseString(register char *spec, XcmsColor *pColor);
+static Status XcmsCIExyY_ValidSpec(XcmsColor *pColor);
+
+
+/*
+ *	LOCAL VARIABLES
+ */
+
+    /*
+     * NULL terminated list of functions applied to get from CIExyY to CIEXYZ
+     */
+static XcmsConversionProc Fl_CIExyY_to_CIEXYZ[] = {
+    XcmsCIExyYToCIEXYZ,
+    NULL
+};
+
+    /*
+     * NULL terminated list of functions applied to get from CIEXYZ to CIExyY
+     */
+static XcmsConversionProc Fl_CIEXYZ_to_CIExyY[] = {
+    XcmsCIEXYZToCIExyY,
+    NULL
+};
+
+
+/*
+ *	GLOBALS
+ */
+
+    /*
+     * CIE xyY Color Space
+     */
+XcmsColorSpace	XcmsCIExyYColorSpace =
+    {
+	_XcmsCIExyY_prefix,	/* prefix */
+	XcmsCIExyYFormat,		/* id */
+	CIExyY_ParseString,	/* parseString */
+	Fl_CIExyY_to_CIEXYZ,	/* to_CIEXYZ */
+	Fl_CIEXYZ_to_CIExyY,	/* from_CIEXYZ */
+	1
+    };
+
+
+
+/************************************************************************
+ *									*
+ *			 PRIVATE ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIExyY_ParseString
+ *
+ *	SYNOPSIS
+ */
+static int
+CIExyY_ParseString(
+    register char *spec,
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		This routines takes a string and attempts to convert
+ *		it into a XcmsColor structure with XcmsCIExyYFormat.
+ *		The assumed CIExyY string syntax is:
+ *		    CIExyY:<x>/<y>/<Y>
+ *		Where x, y, and Y are in string input format for floats
+ *		consisting of:
+ *		    a. an optional sign
+ *		    b. a string of numbers possibly containing a decimal point,
+ *		    c. an optional exponent field containing an 'E' or 'e'
+ *			followed by a possibly signed integer string.
+ *
+ *	RETURNS
+ *		0 if failed, non-zero otherwise.
+ */
+{
+    int n;
+    char *pchar;
+
+    if ((pchar = strchr(spec, ':')) == NULL) {
+	return(XcmsFailure);
+    }
+    n = (int)(pchar - spec);
+
+    /*
+     * Check for proper prefix.
+     */
+    if (strncmp(spec, _XcmsCIExyY_prefix, n) != 0) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Attempt to parse the value portion.
+     */
+    if (sscanf(spec + n + 1, "%lf/%lf/%lf",
+	    &pColor->spec.CIExyY.x,
+	    &pColor->spec.CIExyY.y,
+	    &pColor->spec.CIExyY.Y) != 3) {
+        char *s; /* Maybe failed due to locale */
+        int f;
+        if ((s = strdup(spec))) {
+            for (f = 0; s[f]; ++f)
+                if (s[f] == '.')
+                    s[f] = ',';
+                else if (s[f] == ',')
+                    s[f] = '.';
+	    if (sscanf(s + n + 1, "%lf/%lf/%lf",
+		       &pColor->spec.CIExyY.x,
+		       &pColor->spec.CIExyY.y,
+		       &pColor->spec.CIExyY.Y) != 3) {
+                free(s);
+                return(XcmsFailure);
+            }
+            free(s);
+        } else
+	    return(XcmsFailure);
+    }
+    pColor->format = XcmsCIExyYFormat;
+    pColor->pixel = 0;
+    return(XcmsCIExyY_ValidSpec(pColor));
+}
+
+
+
+/************************************************************************
+ *									*
+ *			 PUBLIC ROUTINES				*
+ *									*
+ ************************************************************************/
+
+/*
+ *	NAME
+ *		CIExyY_ValidSpec()
+ *
+ *	SYNOPSIS
+ */
+static Status
+XcmsCIExyY_ValidSpec(
+    XcmsColor *pColor)
+/*
+ *	DESCRIPTION
+ *		Checks a valid CIExyY color specification.
+ *
+ *	RETURNS
+ *		XcmsFailure if invalid.
+ *		XcmsSuccess if valid.
+ *
+ */
+{
+    if (pColor->format != XcmsCIExyYFormat
+	    ||
+	    (pColor->spec.CIExyY.x < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIExyY.x > 1.0 + XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIExyY.y < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIExyY.y > 1.0 + XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIExyY.Y < 0.0 - XMY_DBL_EPSILON)
+	    ||
+	    (pColor->spec.CIExyY.Y > 1.0 + XMY_DBL_EPSILON)) {
+	return(XcmsFailure);
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIExyYToCIEXYZ - convert CIExyY to CIEXYZ
+ *
+ *	SYNOPSIS
+ */
+Status
+XcmsCIExyYToCIEXYZ(
+    XcmsCCC ccc,
+    XcmsColor *pxyY_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIExyY format to CIEXYZ format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ */
+{
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsColor	whitePt;
+    XcmsCIEXYZ	XYZ_return;
+    XcmsFloat	div;		/* temporary storage in case divisor is zero */
+    XcmsFloat	u, v, x, y, z;	/* temporary storage */
+    register int i;
+
+    /*
+     * Check arguments
+     */
+    if (pxyY_WhitePt == NULL || pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+	/* Make sure original format is CIExyY and valid */
+	if (!XcmsCIExyY_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+
+	if ((div = (-2 * pColor->spec.CIExyY.x) + (12 * pColor->spec.CIExyY.y) + 3) == 0.0) {
+	    /* Note that the divisor is zero */
+	    /* This return is abitrary. */
+	    XYZ_return.X = 0;
+	    XYZ_return.Y = 0;
+	    XYZ_return.Z = 0;
+	} else {
+	    /*
+	     * Make sure white point is in CIEXYZ form
+	     */
+	    if (pxyY_WhitePt->format != XcmsCIEXYZFormat) {
+		/* Make copy of the white point because we're going to modify it */
+		memcpy((char *)&whitePt, (char *)pxyY_WhitePt, sizeof(XcmsColor));
+		if (!_XcmsDIConvertColors(ccc, &whitePt, (XcmsColor *)NULL, 1,
+			XcmsCIEXYZFormat)) {
+		    return(XcmsFailure);
+		}
+		pxyY_WhitePt = &whitePt;
+	    }
+
+	    /* Make sure it is a white point, i.e., Y == 1.0 */
+	    if (pxyY_WhitePt->spec.CIEXYZ.Y != 1.0) {
+		return(XcmsFailure);
+	    }
+
+	    /* Convert from xyY to uvY to XYZ */
+	    u = (4 * pColor->spec.CIExyY.x) / div;
+	    v = (9 * pColor->spec.CIExyY.y) / div;
+	    div = (6.0 * u) - (16.0 * v) + 12.0;
+	    if (div == 0.0) {
+		/* Note that the divisor is zero */
+		/* This return is abitrary. */
+		if ((div = (6.0 * whitePt.spec.CIEuvY.u_prime) -
+		           (16.0 * whitePt.spec.CIEuvY.v_prime) + 12.0) == 0.0) {
+		    div = EPS;
+		}
+		x = 9.0 * whitePt.spec.CIEuvY.u_prime / div;
+		y = 4.0 * whitePt.spec.CIEuvY.u_prime / div;
+	    } else {
+		/* convert u, v to small xyz */
+		x = 9.0 * u / div;
+		y = 4.0 * v / div;
+	    }
+	    z = 1.0 - x - y;
+	    if (y == 0.0) y = EPS;	/* Have to worry about divide by 0 */
+	    XYZ_return.Y = pColor->spec.CIExyY.Y;
+	    XYZ_return.X = x * XYZ_return.Y / y;
+	    XYZ_return.Z = z * XYZ_return.Y / y;
+	}
+
+	/* Copy result to pColor */
+	memcpy ((char *)&pColor->spec, (char *)&XYZ_return, sizeof(XcmsCIEXYZ));
+
+	/* Identify that the format is now CIEXYZ */
+	pColor->format = XcmsCIEXYZFormat;
+    }
+    return(XcmsSuccess);
+}
+
+
+/*
+ *	NAME
+ *		XcmsCIEXYZToCIExyY - convert CIEXYZ to CIExyY
+ *
+ *	SYNOPSIS
+ */
+/* ARGSUSED */
+Status
+XcmsCIEXYZToCIExyY(
+    XcmsCCC ccc,
+    XcmsColor *pxyY_WhitePt,
+    XcmsColor *pColors_in_out,
+    unsigned int nColors)
+/*
+ *	DESCRIPTION
+ *		Converts color specifications in an array of XcmsColor
+ *		structures from CIEXYZ format to CIExyY format.
+ *
+ *	RETURNS
+ *		XcmsFailure if failed,
+ *		XcmsSuccess if succeeded.
+ *
+ */
+{
+    XcmsColor	*pColor = pColors_in_out;
+    XcmsCIExyY	xyY_return;
+    XcmsFloat	div;		/* temporary storage in case divisor is zero */
+    register int i;
+
+    /*
+     * Check arguments
+     * 		pxyY_WhitePt ignored
+     */
+    if (pColors_in_out == NULL) {
+	return(XcmsFailure);
+    }
+
+    /*
+     * Now convert each XcmsColor structure to CIEXYZ form
+     */
+    for (i = 0; i < nColors; i++, pColor++) {
+
+	if (!_XcmsCIEXYZ_ValidSpec(pColor)) {
+	    return(XcmsFailure);
+	}
+	/* Now convert for XYZ to xyY */
+	if ((div = pColor->spec.CIEXYZ.X + pColor->spec.CIEXYZ.Y + pColor->spec.CIEXYZ.Z) == 0.0) {
+	    div = EPS;
+	}
+	xyY_return.x = pColor->spec.CIEXYZ.X / div;
+	xyY_return.y = pColor->spec.CIEXYZ.Y / div;
+	xyY_return.Y = pColor->spec.CIEXYZ.Y;
+
+	/* Copy result to pColor */
+	memcpy ((char *)&pColor->spec, (char *)&xyY_return, sizeof(XcmsCIExyY));
+
+	/* Identify that the format is now CIEXYZ */
+	pColor->format = XcmsCIExyYFormat;
+    }
+    return(XcmsSuccess);
+}
diff --git a/standard_definitions.mk b/standard_definitions.mk
index 5405406..8110ce7 100644
--- a/standard_definitions.mk
+++ b/standard_definitions.mk
@@ -6,7 +6,7 @@ CC=/usr/bin/gcc
 #compilerflags
 COMPFLAGS=-pipe -Os -mtune=i386 -Wall -D_XOPEN_SOURCE=600 -D_BSD_SOURCE -D_GNU_SOURCE -fno-strength-reduce -nodefaultlibs -fno-strict-aliasing  -I. -ffunction-sections -fdata-sections
 
-COMMONDEFS=$(COMPFLAGS) -D_BSD_SOURCE -D_GNU_SOURCE
+COMMONDEFS=$(COMPFLAGS) -D_BSD_SOURCE -D_GNU_SOURCE -DUSECMS
 
 LDFLAGS=-Wl,--gc-sections,--sort-common,-s
 
