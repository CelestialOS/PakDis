--- busybox-1.22.1/editors/sed.c
+++ busybox-1.20.2/editors/sed.c
@@ -23,6 +23,9 @@
  * resulting sed_cmd_t structures are appended to a linked list
  * (G.sed_cmd_head/G.sed_cmd_tail).
  *
+ * add_input_file() adds a FILE* to the list of input files.  We need to
+ * know all input sources ahead of time to find the last line for the $ match.
+ *
  * process_files() does actual sedding, reading data lines from each input FILE*
  * (which could be stdin) and applying the sed command list (sed_cmd_head) to
  * each of the resulting lines.
@@ -69,13 +69,12 @@
 //usage:#define sed_trivial_usage
-//usage:       "[-inrE] [-f FILE]... [-e CMD]... [FILE]...\n"
-//usage:       "or: sed [-inrE] CMD [FILE]..."
+//usage:       "[-inr] [-f FILE]... [-e CMD]... [FILE]...\n"
+//usage:       "or: sed [-inr] CMD [FILE]..."
 //usage:#define sed_full_usage "\n\n"
 //usage:       "	-e CMD	Add CMD to sed commands to be executed"
 //usage:     "\n	-f FILE	Add FILE contents to sed commands to be executed"
-//usage:     "\n	-i[SFX]	Edit files in-place (otherwise sends to stdout)"
-//usage:     "\n		Optionally back files up, appending SFX"
+//usage:     "\n	-i	Edit files in-place (else sends result to stdout)"
 //usage:     "\n	-n	Suppress automatic printing of pattern space"
-//usage:     "\n	-r,-E	Use extended regex syntax"
+//usage:     "\n	-r	Use extended regex syntax"
 //usage:     "\n"
 //usage:     "\nIf no -e or -f, the first non-option argument is the sed command string."
 //usage:     "\nRemaining arguments are input files (stdin if none)."
@@ -132,15 +121,12 @@
 struct globals {
 	/* options */
 	int be_quiet, regex_type;
-
 	FILE *nonstdout;
 	char *outname, *hold_space;
-	smallint exitcode;
 
-	/* list of input files */
-	int current_input_file, last_input_file;
-	char **input_file_list;
-	FILE *current_fp;
+	/* List of input files */
+	int input_file_count, current_input_file;
+	FILE **input_file_list;
 
 	regmatch_t regmatch[10];
 	regex_t *previous_regex_ptr;
@@ -148,7 +134,7 @@
 	/* linked list of sed commands */
 	sed_cmd_t *sed_cmd_head, **sed_cmd_tail;
 
-	/* linked list of append lines */
+	/* Linked list of append lines */
 	llist_t *append_head;
 
 	char *add_cmd_line;
@@ -200,8 +186,8 @@
 
 	free(G.hold_space);
 
-	if (G.current_fp)
-		fclose(G.current_fp);
+	while (G.current_input_file < G.input_file_count)
+		fclose(G.input_file_list[G.current_input_file++]);
 }
 #else
 void sed_free_and_close_stuff(void);
@@ -341,7 +327,7 @@
 		next = index_of_next_unescaped_regexp_delim(delimiter, ++pos);
 		temp = copy_parsing_escapes(pos, next);
 		*regex = xzalloc(sizeof(regex_t));
-		xregcomp(*regex, temp, G.regex_type);
+		xregcomp(*regex, temp, G.regex_type|REG_NEWLINE);
 		free(temp);
 		/* Move position to next character after last delimiter */
 		pos += (next+1);
@@ -381,7 +367,7 @@
 
 	/*
 	 * A substitution command should look something like this:
-	 *    s/match/replace/ #giIpw
+	 *    s/match/replace/ #gIpw
 	 *    ||     |        |||
 	 *    mandatory       optional
 	 */
@@ -429,7 +415,6 @@
 			break;
 		}
 		/* Ignore case (gnu exension) */
-		case 'i':
 		case 'I':
 			cflags |= REG_ICASE;
 			break;
@@ -506,10 +491,8 @@
 	}
 	/* handle edit cmds: (a)ppend, (i)nsert, and (c)hange */
 	else if (idx <= IDX_c) { /* a,i,c */
-		if (idx < IDX_c) { /* a,i */
-			if (sed_cmd->end_line || sed_cmd->end_match)
-				bb_error_msg_and_die("command '%c' uses only one address", sed_cmd->cmd);
-		}
+		if ((sed_cmd->end_line || sed_cmd->end_match) && sed_cmd->cmd != 'c')
+			bb_error_msg_and_die("only a beginning address can be specified for edit commands");
 		for (;;) {
 			if (*cmdstr == '\n' || *cmdstr == '\\') {
 				cmdstr++;
@@ -526,10 +509,8 @@
 	}
 	/* handle file cmds: (r)ead */
 	else if (idx <= IDX_w) { /* r,w */
-		if (idx < IDX_w) { /* r */
-			if (sed_cmd->end_line || sed_cmd->end_match)
-				bb_error_msg_and_die("command '%c' uses only one address", sed_cmd->cmd);
-		}
+		if (sed_cmd->end_line || sed_cmd->end_match)
+			bb_error_msg_and_die("command only uses one address");
 		cmdstr += parse_file_cmd(/*sed_cmd,*/ cmdstr, &sed_cmd->string);
 		if (sed_cmd->cmd == 'w') {
 			sed_cmd->sw_file = xfopen_for_write(sed_cmd->string);
@@ -661,12 +642,6 @@
 		sed_cmd->cmd = *cmdstr++;
 		cmdstr = parse_cmd_args(sed_cmd, cmdstr);
 
-		/* cmdstr now points past args.
-		 * GNU sed requires a separator, if there are more commands,
-		 * else it complains "char N: extra characters after command".
-		 * Example: "sed 'p;d'". We also allow "sed 'pd'".
-		 */
-
 		/* Add the command to the command array */
 		*G.sed_cmd_tail = sed_cmd;
 		G.sed_cmd_tail = &sed_cmd->next;
@@ -697,7 +672,7 @@
 
 	/* go through the replacement string */
 	for (i = 0; replace[i]; i++) {
-		/* if we find a backreference (\1, \2, etc.) print the backref'ed text */
+		/* if we find a backreference (\1, \2, etc.) print the backref'ed * text */
 		if (replace[i] == '\\') {
 			unsigned backref = replace[++i] - '0';
 			if (backref <= 9) {
@@ -731,10 +706,8 @@
 static int do_subst_command(sed_cmd_t *sed_cmd, char **line_p)
 {
 	char *line = *line_p;
+	int altered = 0;
 	unsigned match_count = 0;
-	bool altered = 0;
-	bool prev_match_empty = 1;
-	bool tried_at_eol = 0;
 	regex_t *current_regex;
 
 	current_regex = sed_cmd->sub_match;
@@ -761,75 +734,50 @@
 
 	/* Now loop through, substituting for matches */
 	do {
-		int start = G.regmatch[0].rm_so;
-		int end = G.regmatch[0].rm_eo;
 		int i;
 
+		/* Work around bug in glibc regexec, demonstrated by:
+		 * echo " a.b" | busybox sed 's [^ .]* x g'
+		 * The match_count check is so not to break
+		 * echo "hi" | busybox sed 's/^/!/g'
+		 */
+		if (!G.regmatch[0].rm_so && !G.regmatch[0].rm_eo && match_count) {
+			pipe_putc(*line++);
+			goto next;
+		}
+
 		match_count++;
 
 		/* If we aren't interested in this match, output old line to
-		 * end of match and continue */
+		   end of match and continue */
 		if (sed_cmd->which_match
 		 && (sed_cmd->which_match != match_count)
 		) {
-			for (i = 0; i < end; i++)
+			for (i = 0; i < G.regmatch[0].rm_eo; i++)
 				pipe_putc(*line++);
-			/* Null match? Print one more char */
-			if (start == end && *line)
-				pipe_putc(*line++);
 			goto next;
 		}
 
-		/* Print everything before the match */
-		for (i = 0; i < start; i++)
+		/* print everything before the match */
+		for (i = 0; i < G.regmatch[0].rm_so; i++)
 			pipe_putc(line[i]);
 
-		/* Then print the substitution string,
-		 * unless we just matched empty string after non-empty one.
-		 * Example: string "cccd", pattern "c*", repl "R":
-		 * result is "RdR", not "RRdR": first match "ccc",
-		 * second is "" before "d", third is "" after "d".
-		 * Second match is NOT replaced!
-		 */
-		if (prev_match_empty || start != 0 || start != end) {
-			//dbg("%d %d %d", prev_match_empty, start, end);
-			dbg("inserting replacement at %d in '%s'", start, line);
-			do_subst_w_backrefs(line, sed_cmd->string);
-			/* Flag that something has changed */
-			altered = 1;
-		} else {
-			dbg("NOT inserting replacement at %d in '%s'", start, line);
-		}
+		/* then print the substitution string */
+		do_subst_w_backrefs(line, sed_cmd->string);
 
-		/* If matched string is empty (f.e. "c*" pattern),
-		 * copy verbatim one char after it before attempting more matches
-		 */
-		prev_match_empty = (start == end);
-		if (prev_match_empty) {
-			if (!line[end]) {
-				tried_at_eol = 1;
-			} else {
-				pipe_putc(line[end]);
-				end++;
-			}
-		}
+		/* advance past the match */
+		line += G.regmatch[0].rm_eo;
+		/* flag that something has changed */
+		altered++;
 
-		/* Advance past the match */
-		dbg("line += %d", end);
-		line += end;
-
 		/* if we're not doing this globally, get out now */
 		if (sed_cmd->which_match != 0)
 			break;
  next:
-		/* Exit if we are at EOL and already tried matching at it */
-		if (*line == '\0') {
-			if (tried_at_eol)
-				break;
-			tried_at_eol = 1;
-		}
+		if (*line == '\0')
+			break;
 
-//maybe (end ? REG_NOTBOL : 0) instead of unconditional REG_NOTBOL?
+//maybe (G.regmatch[0].rm_eo ? REG_NOTBOL : 0) instead of unconditional REG_NOTBOL?
 	} while (regexec(current_regex, line, 10, G.regmatch, REG_NOTBOL) != REG_NOMATCH);
 
 	/* Copy rest of string into output pipeline */
@@ -860,100 +808,46 @@
 
 static void append(char *s)
 {
-	llist_add_to_end(&G.append_head, s);
+	llist_add_to_end(&G.append_head, xstrdup(s));
 }
 
-/* Output line of text. */
-/* Note:
- * The tricks with NO_EOL_CHAR and last_puts_char are there to emulate gnu sed.
- * Without them, we had this:
- * echo -n thingy >z1
- * echo -n again >z2
- * >znull
- * sed "s/i/z/" z1 z2 znull | hexdump -vC
- * output:
- * gnu sed 4.1.5:
- * 00000000  74 68 7a 6e 67 79 0a 61  67 61 7a 6e              |thzngy.agazn|
- * bbox:
- * 00000000  74 68 7a 6e 67 79 61 67  61 7a 6e                 |thzngyagazn|
- */
-enum {
-	NO_EOL_CHAR = 1,
-	LAST_IS_NUL = 2,
-};
-static void puts_maybe_newline(char *s, FILE *file, char *last_puts_char, char last_gets_char)
+static void flush_append(void)
 {
-	char lpc = *last_puts_char;
-
-	/* Need to insert a '\n' between two files because first file's
-	 * last line wasn't terminated? */
-	if (lpc != '\n' && lpc != '\0') {
-		fputc('\n', file);
-		lpc = '\n';
-	}
-	fputs(s, file);
-
-	/* 'x' - just something which is not '\n', '\0' or NO_EOL_CHAR */
-	if (s[0])
-		lpc = 'x';
-
-	/* had trailing '\0' and it was last char of file? */
-	if (last_gets_char == LAST_IS_NUL) {
-		fputc('\0', file);
-		lpc = 'x'; /* */
-	} else
-	/* had trailing '\n' or '\0'? */
-	if (last_gets_char != NO_EOL_CHAR) {
-		fputc(last_gets_char, file);
-		lpc = last_gets_char;
-	}
-
-	if (ferror(file)) {
-		xfunc_error_retval = 4;  /* It's what gnu sed exits with... */
-		bb_error_msg_and_die(bb_msg_write_error);
-	}
-	*last_puts_char = lpc;
-}
-
-static void flush_append(char *last_puts_char, char last_gets_char)
-{
 	char *data;
 
 	/* Output appended lines. */
 	while ((data = (char *)llist_pop(&G.append_head))) {
-		puts_maybe_newline(data, G.nonstdout, last_puts_char, last_gets_char);
+		fprintf(G.nonstdout, "%s\n", data);
 		free(data);
 	}
 }
 
+static void add_input_file(FILE *file)
+{
+	G.input_file_list = xrealloc_vector(G.input_file_list, 2, G.input_file_count);
+	G.input_file_list[G.input_file_count++] = file;
+}
+
 /* Get next line of input from G.input_file_list, flushing append buffer and
  * noting if we ran out of files without a newline on the last line we read.
  */
-static char *get_next_line(char *gets_char, char *last_puts_char, char last_gets_char)
+enum {
+	NO_EOL_CHAR = 1,
+	LAST_IS_NUL = 2,
+};
+static char *get_next_line(char *gets_char)
 {
 	char *temp = NULL;
 	int len;
 	char gc;
 
-	flush_append(last_puts_char, last_gets_char);
+	flush_append();
 
 	/* will be returned if last line in the file
 	 * doesn't end with either '\n' or '\0' */
 	gc = NO_EOL_CHAR;
-	for (; G.current_input_file <= G.last_input_file; G.current_input_file++) {
-		FILE *fp = G.current_fp;
-		if (!fp) {
-			const char *path = G.input_file_list[G.current_input_file];
-			fp = stdin;
-			if (path != bb_msg_standard_input) {
-				fp = fopen_or_warn(path, "r");
-				if (!fp) {
-					G.exitcode = EXIT_FAILURE;
-					continue;
-				}
-			}
-			G.current_fp = fp;
-		}
+	while (G.current_input_file < G.input_file_count) {
+		FILE *fp = G.input_file_list[G.current_input_file];
 		/* Read line up to a newline or NUL byte, inclusive,
 		 * return malloc'ed char[]. length of the chunk read
 		 * is stored in len. NULL if EOF/error */
@@ -984,13 +878,61 @@
 		 * (note: *no* newline after "b bang"!) */
 		}
 		/* Close this file and advance to next one */
-		fclose_if_not_stdin(fp);
-		G.current_fp = NULL;
+		fclose(fp);
+		G.current_input_file++;
 	}
 	*gets_char = gc;
 	return temp;
 }
 
+/* Output line of text. */
+/* Note:
+ * The tricks with NO_EOL_CHAR and last_puts_char are there to emulate gnu sed.
+ * Without them, we had this:
+ * echo -n thingy >z1
+ * echo -n again >z2
+ * >znull
+ * sed "s/i/z/" z1 z2 znull | hexdump -vC
+ * output:
+ * gnu sed 4.1.5:
+ * 00000000  74 68 7a 6e 67 79 0a 61  67 61 7a 6e              |thzngy.agazn|
+ * bbox:
+ * 00000000  74 68 7a 6e 67 79 61 67  61 7a 6e                 |thzngyagazn|
+ */
+static void puts_maybe_newline(char *s, FILE *file, char *last_puts_char, char last_gets_char)
+{
+	char lpc = *last_puts_char;
+
+	/* Need to insert a '\n' between two files because first file's
+	 * last line wasn't terminated? */
+	if (lpc != '\n' && lpc != '\0') {
+		fputc('\n', file);
+		lpc = '\n';
+	}
+	fputs(s, file);
+
+	/* 'x' - just something which is not '\n', '\0' or NO_EOL_CHAR */
+	if (s[0])
+		lpc = 'x';
+
+	/* had trailing '\0' and it was last char of file? */
+	if (last_gets_char == LAST_IS_NUL) {
+		fputc('\0', file);
+		lpc = 'x'; /* */
+	} else
+	/* had trailing '\n' or '\0'? */
+	if (last_gets_char != NO_EOL_CHAR) {
+		fputc(last_gets_char, file);
+		lpc = last_gets_char;
+	}
+
+	if (ferror(file)) {
+		xfunc_error_retval = 4;  /* It's what gnu sed exits with... */
+		bb_error_msg_and_die(bb_msg_write_error);
+	}
+	*last_puts_char = lpc;
+}
+
 #define sed_puts(s, n) (puts_maybe_newline(s, G.nonstdout, &last_puts_char, n))
 
 static int beg_match(sed_cmd_t *sed_cmd, const char *pattern_space)
@@ -1013,7 +955,7 @@
 	int substituted;
 
 	/* Prime the pump */
-	next_line = get_next_line(&next_gets_char, &last_puts_char, '\n' /*last_gets_char*/);
+	next_line = get_next_line(&next_gets_char);
 
 	/* Go through every line in each file */
  again:
@@ -1027,7 +969,7 @@
 
 	/* Read one line in advance so we can act on the last line,
 	 * the '$' address */
-	next_line = get_next_line(&next_gets_char, &last_puts_char, last_gets_char);
+	next_line = get_next_line(&next_gets_char);
 	linenum++;
 
 	/* For every line, go through all the commands */
@@ -1101,7 +1043,7 @@
 				/* or does this line matches our last address regex */
 				|| (sed_cmd->end_match && old_matched
 				     && (regexec(sed_cmd->end_match,
-						pattern_space, 0, NULL, 0) == 0)
+				                 pattern_space, 0, NULL, 0) == 0)
 				)
 			);
 		}
@@ -1184,7 +1126,7 @@
 		case 's':
 			if (!do_subst_command(sed_cmd, &pattern_space))
 				break;
-			dbg("do_subst_command succeeded:'%s'", pattern_space);
+			dbg("do_subst_command succeeeded:'%s'", pattern_space);
 			substituted |= 1;
 
 			/* handle p option */
@@ -1199,7 +1141,7 @@
 
 		/* Append line to linked list to be printed later */
 		case 'a':
-			append(xstrdup(sed_cmd->string));
+			append(sed_cmd->string);
 			break;
 
 		/* Insert text before this line */
@@ -1221,10 +1163,11 @@
 			rfile = fopen_for_read(sed_cmd->string);
 			if (rfile) {
 				char *line;
+
 				while ((line = xmalloc_fgetline(rfile))
 						!= NULL)
 					append(line);
-				fclose(rfile);
+				xprint_and_close_file(rfile);
 			}
 
 			break;
@@ -1245,7 +1188,7 @@
 				free(pattern_space);
 				pattern_space = next_line;
 				last_gets_char = next_gets_char;
-				next_line = get_next_line(&next_gets_char, &last_puts_char, last_gets_char);
+				next_line = get_next_line(&next_gets_char);
 				substituted = 0;
 				linenum++;
 				break;
@@ -1281,7 +1224,7 @@
 			pattern_space[len] = '\n';
 			strcpy(pattern_space + len+1, next_line);
 			last_gets_char = next_gets_char;
-			next_line = get_next_line(&next_gets_char, &last_puts_char, last_gets_char);
+			next_line = get_next_line(&next_gets_char);
 			linenum++;
 			break;
 		}
@@ -1385,7 +1328,7 @@
 
 	/* Delete and such jump here. */
  discard_line:
-	flush_append(&last_puts_char, last_gets_char);
+	flush_append();
 	free(pattern_space);
 
 	goto again;
@@ -1394,7 +1337,7 @@
 /* It is possible to have a command line argument with embedded
  * newlines.  This counts as multiple command lines.
  * However, newline can be escaped: 's/e/z\<newline>z/'
- * add_cmd() handles this.
+ * We check for this.
  */
 
 static void add_cmd_block(char *cmdstr)
@@ -1404,8 +1347,22 @@
 	cmdstr = sv = xstrdup(cmdstr);
 	do {
 		eol = strchr(cmdstr, '\n');
-		if (eol)
+ next:
+		if (eol) {
+			/* Count preceding slashes */
+			int slashes = 0;
+			char *sl = eol;
+
+			while (sl != cmdstr && *--sl == '\\')
+				slashes++;
+			/* Odd number of preceding slashes - newline is escaped */
+			if (slashes & 1) {
+				overlapping_strcpy(eol - 1, eol);
+				eol = strchr(eol, '\n');
+				goto next;
+			}
 			*eol = '\0';
+		}
 		add_cmd(cmdstr);
 		cmdstr = eol + 1;
 	} while (eol);
@@ -1417,54 +1374,33 @@
 {
 	unsigned opt;
 	llist_t *opt_e, *opt_f;
-	char *opt_i;
+	int status = EXIT_SUCCESS;
 
-#if ENABLE_LONG_OPTS
-	static const char sed_longopts[] ALIGN1 =
-		/* name             has_arg             short */
-		"in-place\0"        Optional_argument   "i"
-		"regexp-extended\0" No_argument         "r"
-		"quiet\0"           No_argument         "n"
-		"silent\0"          No_argument         "n"
-		"expression\0"      Required_argument   "e"
-		"file\0"            Required_argument   "f";
-#endif
-
 	INIT_G();
 
 	/* destroy command strings on exit */
 	if (ENABLE_FEATURE_CLEAN_UP) atexit(sed_free_and_close_stuff);
 
 	/* Lie to autoconf when it starts asking stupid questions. */
-	if (argv[1] && strcmp(argv[1], "--version") == 0) {
+	if (argv[1] && !strcmp(argv[1], "--version")) {
 		puts("This is not GNU sed version 4.0");
 		return 0;
 	}
 
 	/* do normal option parsing */
 	opt_e = opt_f = NULL;
-	opt_i = NULL;
 	opt_complementary = "e::f::" /* can occur multiple times */
 	                    "nn"; /* count -n */
-
-	IF_LONG_OPTS(applet_long_options = sed_longopts);
-
 	/* -i must be first, to match OPT_in_place definition */
-	/* -E is a synonym of -r:
-	 * GNU sed 4.2.1 mentions it in neither --help
-	 * nor manpage, but does recognize it.
-	 */
-	opt = getopt32(argv, "i::rEne:f:", &opt_i, &opt_e, &opt_f,
+	opt = getopt32(argv, "irne:f:", &opt_e, &opt_f,
 			    &G.be_quiet); /* counter for -n */
 	//argc -= optind;
 	argv += optind;
 	if (opt & OPT_in_place) { // -i
 		atexit(cleanup_outname);
 	}
-	if (opt & (2|4))
-		G.regex_type |= REG_EXTENDED; // -r or -E
-	//if (opt & 8)
-	//	G.be_quiet++; // -n (implemented with a counter instead)
+	if (opt & 0x2) G.regex_type |= REG_EXTENDED; // -r
+	//if (opt & 0x4) G.be_quiet++; // -n
 	while (opt_e) { // -e
 		add_cmd_block(llist_pop(&opt_e));
 	}
@@ -1479,7 +1415,7 @@
 		fclose(cmdfile);
 	}
 	/* if we didn't get a pattern from -e or -f, use argv[0] */
-	if (!(opt & 0x30)) {
+	if (!(opt & 0x18)) {
 		if (!*argv)
 			bb_show_usage();
 		add_cmd_block(*argv++);
@@ -1493,38 +1429,42 @@
 	/* argv[0..(argc-1)] should be names of file to process. If no
 	 * files were specified or '-' was specified, take input from stdin.
 	 * Otherwise, we process all the files specified. */
-	G.input_file_list = argv;
-	if (!argv[0]) {
+	if (argv[0] == NULL) {
 		if (opt & OPT_in_place)
 			bb_error_msg_and_die(bb_msg_requires_arg, "-i");
-		argv[0] = (char*)bb_msg_standard_input;
-		/* G.last_input_file = 0; - already is */
+		add_input_file(stdin);
 	} else {
-		goto start;
+		int i;
 
-		for (; *argv; argv++) {
+		for (i = 0; argv[i]; i++) {
 			struct stat statbuf;
 			int nonstdoutfd;
+			FILE *file;
 			sed_cmd_t *sed_cmd;
 
-			G.last_input_file++;
- start:
+			if (LONE_DASH(argv[i]) && !(opt & OPT_in_place)) {
+				add_input_file(stdin);
+				process_files();
+				continue;
+			}
+			file = fopen_or_warn(argv[i], "r");
+			if (!file) {
+				status = EXIT_FAILURE;
+				continue;
+			}
+			add_input_file(file);
 			if (!(opt & OPT_in_place)) {
-				if (LONE_DASH(*argv)) {
-					*argv = (char*)bb_msg_standard_input;
-					process_files();
-				}
 				continue;
 			}
 
 			/* -i: process each FILE separately: */
 
-			G.outname = xasprintf("%sXXXXXX", *argv);
+			G.outname = xasprintf("%sXXXXXX", argv[i]);
 			nonstdoutfd = xmkstemp(G.outname);
 			G.nonstdout = xfdopen_for_write(nonstdoutfd);
 
 			/* Set permissions/owner of output file */
-			stat(*argv, &statbuf);
+			fstat(fileno(file), &statbuf);
 			/* chmod'ing AFTER chown would preserve suid/sgid bits,
 			 * but GNU sed 4.2.1 does not preserve them either */
 			fchmod(nonstdoutfd, statbuf.st_mode);
@@ -1534,13 +1474,8 @@
 			fclose(G.nonstdout);
 			G.nonstdout = stdout;
 
-			if (opt_i) {
-				char *backupname = xasprintf("%s%s", *argv, opt_i);
-				xrename(*argv, backupname);
-				free(backupname);
-			}
-			/* else unlink(*argv); - rename below does this */
-			xrename(G.outname, *argv); //TODO: rollback backup on error?
+			/* unlink(argv[i]); */
+			xrename(G.outname, argv[i]);
 			free(G.outname);
 			G.outname = NULL;
 
@@ -1550,13 +1485,12 @@
 			}
 		}
 		/* Here, to handle "sed 'cmds' nonexistent_file" case we did:
-		 * if (G.current_input_file[G.current_input_file] == NULL)
-		 *	return G.exitcode;
+		 * if (G.current_input_file >= G.input_file_count)
+		 *	return status;
 		 * but it's not needed since process_files() works correctly
 		 * in this case too. */
 	}
-
 	process_files();
 
-	return G.exitcode;
+	return status;
 }
